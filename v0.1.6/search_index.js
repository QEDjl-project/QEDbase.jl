var documenterSearchIndex = {"docs":
[{"location":"lorentz_vectors/#Lorentz-vectors","page":"Lorentz Vectors","title":"Lorentz vectors","text":"","category":"section"},{"location":"lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"In oder to model Lorentz vectors, i.e. elements of a Minkowski space, we use a generic type called LorentzVector{T}.","category":"page"},{"location":"library/function_index/#main-index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Pages = [\"api.md\", \"function_index.md\"]","category":"page"},{"location":"library/outline/#API-Outline","page":"Contents","title":"API Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"api.md\", \"function_index.md\"]","category":"page"},{"location":"library/api/#QEDbase","page":"API","title":"QEDbase","text":"","category":"section"},{"location":"library/api/","page":"API","title":"API","text":"Modules = [QEDbase]\nPages = [\"QEDbase.jl\"]\nOrder = [:module]","category":"page"},{"location":"library/api/#Lorentz-Vector-Interface","page":"API","title":"Lorentz Vector Interface","text":"","category":"section"},{"location":"library/api/","page":"API","title":"API","text":"Modules = [QEDbase]\nPages   = [\"lorentz_interface.jl\"]\nOrder   = [:type,:function]","category":"page"},{"location":"library/api/#QEDbase.RegistryError","page":"API","title":"QEDbase.RegistryError","text":"struct RegistryError <: Exception\n\nException raised, if a certain type target_type can not be registed for a certain interface, since there needs the function func to be impleemnted.\n\nFields\n\nfunc::Function\ntarget_type::Any\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase._hasmethod_registry-Union{Tuple{T}, Tuple{Function, Type{T}}} where T","page":"API","title":"QEDbase._hasmethod_registry","text":"_hasmethod_registry(fun, _)\n\n\nWrapper around Base.hasmethod with a more meaningful error message in the context of function registration.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getBeta-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getBeta","text":"getBeta(lv)\n\nReturn magnitude of the beta vector for a given LorentzVectorLike, i.e. the magnitude of the LorentzVectorLike divided by its 0-component.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to sqrt(px^2 + py^2 + pz^2)/E.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getCosPhi-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getCosPhi","text":"getCosPhi(lv)\n\nReturn the cosine of the phi angle for a given LorentzVectorLike.\n\nnote: Note\nThis is an equivalent but faster version of cos(getPhi(lv)); see getPhi.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getCosTheta-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getCosTheta","text":"getCosTheta(lv)\n\nReturn the cosine of the theta angle for a given LorentzVectorLike.\n\nnote: Note\nThis is an equivalent but faster version of cos(getTheta(lv)); see getTheta.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getE-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getE","text":"getE(lv)\n\nReturn the energy component of a given LorentzVectorLike, i.e. its 0-component. \n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to E.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getEnergy","page":"API","title":"QEDbase.getEnergy","text":"Function alias for getE.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getGamma-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getGamma","text":"getGamma(lv)\n\nReturn the relativistic gamma factor for a given LorentzVectorLike, i.e. the inverse square root of one minus the beta vector squared.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike with beta vector β, this is equivalent to 1/sqrt(1- β^2).\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getInvariantMass-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getInvariantMass","text":"getInvariantMass(lv)\n\nReturn the the invariant mass of a given LorentzVectorLike, i.e. the square root of the minkowski dot with itself. \n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to sqrt(t^2 - (x^2 + y^2 + z^2)).\n\nnote: Note\nIf the squared invariant mass m2 is negative, -sqrt(-m2) is returned. \n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getInvariantMass2-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getInvariantMass2","text":"getInvariantMass2(lv)\n\nReturn the squared invariant mass of a given LorentzVectorLike, i.e. the minkowski dot with itself. \n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to t^2 - (x^2 + y^2 + z^2). \n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getMag","page":"API","title":"QEDbase.getMag","text":"Functiom alias for getMagnitude.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getMag2","page":"API","title":"QEDbase.getMag2","text":"Functiom alias for getMagnitude2.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getMagnitude-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getMagnitude","text":"getMagnitude(lv)\n\nReturn the magnitude of a given LorentzVectorLike, i.e. the euklidian norm spatial components. \n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to sqrt(x^2 + y^2 + z^2).\n\nwarning: Warning\nThis function differs from a similar function for the TLorentzVector used in the famous ROOT library.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getMagnitude2-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getMagnitude2","text":"getMagnitude2(lv)\n\nReturn the square of the magnitude of a given LorentzVectorLike, i.e. the sum of the squared spatial components. \n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to x^2+ y^2 + z^2.\n\nwarning: Warning\nThis function differs from a similar function for the TLorentzVector used in the famous ROOT library.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getMass","page":"API","title":"QEDbase.getMass","text":"Function alias for getInvariantMass.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getMass2","page":"API","title":"QEDbase.getMass2","text":"Function alias for getInvariantMass2\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getMinus-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getMinus","text":"getMinus(lv)\n\nReturn the minus component for a given LorentzVectorLike in light-cone coordinates.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to (E-pz)/2.\n\nnote: Note\nThe light-cone coordinates are defined w.r.t. to the 3-axis.\n\nwarning: Warning\nThe definition `p^- := (E - p_z)/2 differs from the usual definition of light-cone coordinates in general relativity.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getMt","page":"API","title":"QEDbase.getMt","text":"Function alias for getTransverseMass\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getMt2","page":"API","title":"QEDbase.getMt2","text":"Function alias for getTransverseMass2\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getPerp","page":"API","title":"QEDbase.getPerp","text":"Function alias for getTransverseMomentum.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getPerp2","page":"API","title":"QEDbase.getPerp2","text":"Function alias for getTransverseMomentum2.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getPhi-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getPhi","text":"getPhi(lv)\n\nReturn the phi angle for a given LorentzVectorLike, i.e. the azimuthal angle of its spatial components in spherical coordinates.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to atan(py,px).\n\nnote: Note\nThe spherical coordinates are defined w.r.t. to the 3-axis. \n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getPlus-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getPlus","text":"getPlus(lv)\n\nReturn the plus component for a given LorentzVectorLike in light-cone coordinates.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to (E+pz)/2.\n\nnote: Note\nThe light-cone coordinates are defined w.r.t. to the 3-axis.\n\nwarning: Warning\nThe definition `p^+ := (E + p_z)/2 differs from the usual definition of light-cone coordinates in general relativity.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getPt","page":"API","title":"QEDbase.getPt","text":"Function alias for getTransverseMomentum.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getPt2","page":"API","title":"QEDbase.getPt2","text":"Function alias for getTransverseMomentum2.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getPx-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getPx","text":"getPx(lv)\n\nReturn the p_x component of a given LorentzVectorLike, i.e. its 1-component. \n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to px.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getPy-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getPy","text":"getPy(lv)\n\nReturn the p_y component of a given LorentzVectorLike, i.e. its 2-component. \n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to py.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getPz-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getPz","text":"getPz(lv)\n\nReturn the p_z component of a given LorentzVectorLike, i.e. its 3-component. \n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to pz.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getRapidity-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getRapidity","text":"getRapidity(lv)\n\nReturn the rapidity for a given LorentzVectorLike.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to 0.5*log((E+pz)/(E-pz)).\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis. \n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getRho","page":"API","title":"QEDbase.getRho","text":"Function alias for getMagnitude\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getRho2","page":"API","title":"QEDbase.getRho2","text":"Function alias for getMagnitude2\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getSinPhi-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getSinPhi","text":"getSinPhi(lv)\n\nReturn the sine of the phi angle for a given LorentzVectorLike.\n\nnote: Note\nThis is an equivalent but faster version of sin(getPhi(lv)); see getPhi.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getT","page":"API","title":"QEDbase.getT","text":"getT(lv)\n\nReturn the 0-component of a given LorentzVectorLike.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to t.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getTheta-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getTheta","text":"getTheta(lv)\n\nReturn the theta angle for a given LorentzVectorLike, i.e. the polar angle of its spatial components in spherical coordinates.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike with magnitude rho, this is equivalent to arccos(pz/rho), which is also equivalent to arctan(sqrt(px^2+py^2)/pz).\n\nnote: Note\nThe spherical coordinates are defined w.r.t. to the 3-axis. \n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getTransverseMass-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getTransverseMass","text":"getTransverseMass(lv)\n\nReturn the transverse momentum for a given LorentzVectorLike, i.e. the square root of its squared transverse mass.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to sqrt(E^2 - pz^2).\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis. \n\nnote: Note\nIf the squared transverse mass mT2 is negative, -sqrt(-mT2) is returned.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getTransverseMass2-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getTransverseMass2","text":"getTransverseMass2(lv)\n\nReturn the squared transverse mass for a given LorentzVectorLike, i.e. the difference of its squared 0- and 3-component.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to E^2 - pz^2.\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis. \n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getTransverseMomentum-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getTransverseMomentum","text":"getTransverseMomentum(lv)\n\nReturn the transverse momentum for a given LorentzVectorLike, i.e. the magnitude of its transverse components.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to sqrt(px^2 + py^2).\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis. \n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getTransverseMomentum2-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"API","title":"QEDbase.getTransverseMomentum2","text":"getTransverseMomentum2(lv)\n\nReturn the squared transverse momentum for a given LorentzVectorLike, i.e. the sum of its squared 1- and 2-component.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to px^2 + py^2.\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis. \n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.getX","page":"API","title":"QEDbase.getX","text":"getX(lv)\n\nReturn the 1-component of a given LorentzVectorLike.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to x.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getY","page":"API","title":"QEDbase.getY","text":"getY(lv)\n\nReturn the 2-component of a given LorentzVectorLike.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to y.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.getZ","page":"API","title":"QEDbase.getZ","text":"getZ(lv)\n\nReturn the 3-component of a given LorentzVectorLike.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to z.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.mdot","page":"API","title":"QEDbase.mdot","text":"Function alias for minkowski_dot.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.minkowski_dot-Union{Tuple{T2}, Tuple{T1}, Tuple{Type{QEDbase.IsLorentzVectorLike{T1}}, T1, T2}} where {T1, T2}","page":"API","title":"QEDbase.minkowski_dot","text":"minkowski_dot(v1,v2)\n\nReturn the Minkowski dot product of two LorentzVectorLike. \n\nexample: Example\nIf (t1,x1,y1,z1) and (t2,x2,y2,z2) are two LorentzVectorLike, this is equivalent to t1*t2 - (x1*x2 + y1*y2 + z1*z2)\n\nnote: Note\nWe use the mostly minus metric.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.register_LorentzVectorLike-Tuple{Type}","page":"API","title":"QEDbase.register_LorentzVectorLike","text":"register_LorentzVectorLike(T)\n\n\nFunction to register a custom type as a LorentzVectorLike. \n\nEnsure the passed custom type has implemented at least the function getT, getX, getY, getZ  and enables getter functions of the lorentz vector library for the given type.  If additionally the functions setT!, setX!, setY!, setZ! are implemened for the passed custom type, also the setter functions of the Lorentz vector interface are enabled.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.setCosTheta!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"API","title":"QEDbase.setCosTheta!","text":"setCosTheta!(lv,value)\n\nSets the cosine of the theta angle of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setCosTheta! is then returned by getCosTheta. Since the cosine of the theta angle is computed on the call of getCosTheta, the setter setCosTheta! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.setE!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"API","title":"QEDbase.setE!","text":"setE!(lv,value)\n\nSets the energy component of a given LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setE! is then returned by getE.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.setEnergy!","page":"API","title":"QEDbase.setEnergy!","text":"Function alias for setE!.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.setMinus!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"API","title":"QEDbase.setMinus!","text":"setMinus!(lv,value)\n\nSets the minus component of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setMinus! is then returned by getMinus. Since the minus component is computed on the call of getMinus, the setter setMinus! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.setMt!","page":"API","title":"QEDbase.setMt!","text":"Function alias for setTransverseMass!.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.setPerp!","page":"API","title":"QEDbase.setPerp!","text":"Function alias for setTransverseMomentum!.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.setPhi!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"API","title":"QEDbase.setPhi!","text":"setPhi!(lv,value)\n\nSets the phi angle of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPhi! is then returned by getPhi. Since the phi angle is computed on the call of getPhi, the setter setPhi! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.setPlus!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"API","title":"QEDbase.setPlus!","text":"setPlus!(lv,value)\n\nSets the plus component of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPlus! is then returned by getPlus. Since the plus component is computed on the call of getPlus, the setter setPlus! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.setPt!","page":"API","title":"QEDbase.setPt!","text":"Function alias for setTransverseMomentum!.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.setPx!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"API","title":"QEDbase.setPx!","text":"setPx!(lv,value)\n\nSets the 1-component of a given LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPx! is then returned by getPx.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.setPy!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"API","title":"QEDbase.setPy!","text":"setPy!(lv,value)\n\nSets the 2-component of a given LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPy! is then returned by getPy.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.setPz!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"API","title":"QEDbase.setPz!","text":"setPz!(lv,value)\n\nSets the 3-component of a given LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPz! is then returned by getPz.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.setRapidity!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"API","title":"QEDbase.setRapidity!","text":"setRapidity!(lv,value)\n\nSets the rapidity of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setRapidity! is then returned by getRapidity. Since the rapidity is computed on the call of setRapidity, the setter setRapidity! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.setRho!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"API","title":"QEDbase.setRho!","text":"setRho!(lv,value)\n\nSets the magnitude of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setRho! is then returned by getRho. Since the magnitude is computed on the call of getRho, the setter setRho! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.setT!","page":"API","title":"QEDbase.setT!","text":"setT!(lv,value)\n\nSets the 0-component of a given LorentzVectorLike to the given value.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.setTheta!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"API","title":"QEDbase.setTheta!","text":"setTheta!(lv,value)\n\nSets the theta angle of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setTheta! is then returned by getTheta. Since the theta angle is computed on the call of getTheta, the setter setTheta! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.setTransverseMass!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"API","title":"QEDbase.setTransverseMass!","text":"setTransverseMass!(lv,value)\n\nSets the transverse mass of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setTransverseMass! is then returned by getTransverseMass. Since the transverse mass is computed on the call of getTransverseMass, the setter setTransverseMass! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.setTransverseMomentum!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"API","title":"QEDbase.setTransverseMomentum!","text":"setTransverseMomentum!(lv,value)\n\nSets the transverse momentum of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setTransverseMomentum! is then returned by getTransverseMomentum. Since the transverse momentum is computed on the call of getTransverseMomentum, the setter setTransverseMomentum! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.setX!","page":"API","title":"QEDbase.setX!","text":"setX!(lv,value)\n\nSets the 1-component of a given LorentzVectorLike to the given value.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.setY!","page":"API","title":"QEDbase.setY!","text":"setY!(lv,value)\n\nSets the 2-component of a given LorentzVectorLike to the given value.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.setZ!","page":"API","title":"QEDbase.setZ!","text":"setZ!(lv,value)\n\nSets the 3-component of a given LorentzVectorLike to the given value.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#Lorentz-Vectors","page":"API","title":"Lorentz Vectors","text":"","category":"section"},{"location":"library/api/","page":"API","title":"API","text":"Modules = [QEDbase]\nPages   = [\"lorentz_vector.jl\"]\nOrder   = [:type,:function]","category":"page"},{"location":"library/api/#QEDbase.AbstractLorentzVector","page":"API","title":"QEDbase.AbstractLorentzVector","text":"abstract type AbstractLorentzVector{T} <: StaticArraysCore.FieldVector{4, T}\n\nAbstract type to model generic Lorentz vectors, i.e. elements of a minkowski-like space, where the component space is arbitray.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.MLorentzVector","page":"API","title":"QEDbase.MLorentzVector","text":"mutable struct MLorentzVector{T} <: AbstractLorentzVector{T}\n\nConcrete implementation of a generic mutable Lorentz vector. Each manipulation of an concrete implementation which is not self-contained (i.e. produces the same Lorentz vector type) will result in this type.\n\nFields\n\nt::Any: t component\nx::Any: x component\ny::Any: y component\nz::Any: z component\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.SLorentzVector","page":"API","title":"QEDbase.SLorentzVector","text":"struct SLorentzVector{T} <: AbstractLorentzVector{T}\n\nConcrete implementation of a generic static Lorentz vector. Each manipulation of an concrete implementation which is not self-contained (i.e. produces the same Lorentz vector type) will result in this type.\n\nFields\n\nt::Any: t component\nx::Any: x component\ny::Any: y component\nz::Any: z component\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.mul-Union{Tuple{TL}, Tuple{T}, Tuple{T, TL}} where {T<:Union{AbstractDiracMatrix, AbstractDiracVector}, TL<:AbstractLorentzVector}","page":"API","title":"QEDbase.mul","text":"mul(\n    DM::Union{AbstractDiracMatrix, AbstractDiracVector},\n    L::AbstractLorentzVector\n) -> Any\n\n\nProduct of generic Lorentz vector with a Dirac tensor from the left. Basically, the multiplication is piped to the components from the Lorentz vector.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.mul-Union{Tuple{T}, Tuple{TL}, Tuple{TL, T}} where {TL<:AbstractLorentzVector, T<:Union{AbstractDiracMatrix, AbstractDiracVector}}","page":"API","title":"QEDbase.mul","text":"mul(\n    L::AbstractLorentzVector,\n    DM::Union{AbstractDiracMatrix, AbstractDiracVector}\n) -> Any\n\n\nProduct of generic Lorentz vector with a Dirac tensor from the right. Basically, the multiplication is piped to the components from the Lorentz vector.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#Four-Momentum","page":"API","title":"Four Momentum","text":"","category":"section"},{"location":"library/api/","page":"API","title":"API","text":"Modules = [QEDbase]\nPages   = [\"four_momentum.jl\"]\nOrder   = [:type,:function]","category":"page"},{"location":"library/api/#QEDbase.MFourMomentum","page":"API","title":"QEDbase.MFourMomentum","text":"mutable struct MFourMomentum <: QEDbase.AbstractFourMomentum\n\nBuilds a mutable LorentzVector with real components used to statically model the four-momentum of a particle or field.\n\nFields\n\nE::Float64: energy component\npx::Float64: x component\npy::Float64: y component\npz::Float64: z component\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.MFourMomentum-Union{Tuple{T}, NTuple{4, T}} where T<:Union{Integer, Irrational, Rational}","page":"API","title":"QEDbase.MFourMomentum","text":"MFourMomentum(t, x, y, z)\n\n\nThe interface transforms each number-like input to float64:\n\nMFourMomentum(\n    t::Union{Integer, Irrational, Rational},\n    x::Union{Integer, Irrational, Rational},\n    y::Union{Integer, Irrational, Rational},\n    z::Union{Integer, Irrational, Rational}\n) -> MFourMomentum\n\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.SFourMomentum","page":"API","title":"QEDbase.SFourMomentum","text":"struct SFourMomentum <: QEDbase.AbstractFourMomentum\n\nBuilds a static LorentzVectorLike with real components used to statically model the four-momentum of a particle or field.\n\nFields\n\nE::Float64: energy component\npx::Float64: x component\npy::Float64: y component\npz::Float64: z component\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.SFourMomentum-Union{Tuple{T}, NTuple{4, T}} where T<:Union{Integer, Irrational, Rational}","page":"API","title":"QEDbase.SFourMomentum","text":"SFourMomentum(t, x, y, z)\n\n\nThe interface transforms each number-like input to float64:\n\nSFourMomentum(\n    t::Union{Integer, Irrational, Rational},\n    x::Union{Integer, Irrational, Rational},\n    y::Union{Integer, Irrational, Rational},\n    z::Union{Integer, Irrational, Rational}\n) -> SFourMomentum\n\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.assert_onshell-Tuple{AbstractLorentzVector, Real}","page":"API","title":"QEDbase.assert_onshell","text":"assert_onshell(mom, mass)\n\n\nAssertion if a FourMomentum mom is on-shell w.r.t a given mass mass.\n\nnote: See also\nThe precision of this functions is explained in isonshell.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.isonshell-Union{Tuple{T}, Tuple{AbstractLorentzVector{T}, Real}} where T<:Real","page":"API","title":"QEDbase.isonshell","text":"isonshell(mom, mass)\n\n\nOn-shell check of a given four-momentum mom w.r.t. a given mass mass. \n\nnote: Precision\nFor AbstactFourMomentum, the element type is fixed to Float64, limiting the precision of comparisons between elements. The current implementation has been tested within the boundaries for energy scales E with 1e-9 <= E <= 1e5.  In those bounds, the mass error, which is correctly detected as off-shell, is 1e-4 times the mean value of the components, but has at most the value 0.01, e.g. at the high energy end. The energy scales correspond to 0.5 meV for the lower bound and 50 GeV for the upper bound.\n\ntodo: FourMomenta with real entries\nif AbstractFourMomentum is updated to elementtypes T<:Real, the AbstractLorentzVector should be updated with the AbstractFourMomentum.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#Dirac-Tensors","page":"API","title":"Dirac Tensors","text":"","category":"section"},{"location":"library/api/","page":"API","title":"API","text":"Modules = [QEDbase]\nPages   = [\"dirac_tensors.jl\"]\nOrder   = [:type,:function]","category":"page"},{"location":"library/api/#QEDbase.AbstractDiracMatrix","page":"API","title":"QEDbase.AbstractDiracMatrix","text":"abstract type AbstractDiracMatrix{T} <: StaticArraysCore.FieldMatrix{4, 4, T}\n\nAbstract type for Dirac matrices, i.e. matrix representations for linear mappings from a spinor space into another.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.AbstractDiracVector","page":"API","title":"QEDbase.AbstractDiracVector","text":"abstract type AbstractDiracVector{T} <: StaticArraysCore.FieldVector{4, T}\n\nAbstract type for Dirac vectors, e.g. four dimensional vectors from a spinor space.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.AdjointBiSpinor","page":"API","title":"QEDbase.AdjointBiSpinor","text":"struct AdjointBiSpinor <: AbstractDiracVector{ComplexF64}\n\nConcrete type to model an adjoint Dirac four-spinor with complex-valued components. These are the elements of the dual spinor space.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.BiSpinor","page":"API","title":"QEDbase.BiSpinor","text":"struct BiSpinor <: AbstractDiracVector{ComplexF64}\n\nConcrete type to model a Dirac four-spinor with complex-valued components. These are the elements of an actual spinor space.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.DiracMatrix","page":"API","title":"QEDbase.DiracMatrix","text":"struct DiracMatrix <: AbstractDiracMatrix{ComplexF64}\n\nConcrete type to model Dirac matrices, i.e. matrix representations of linear mappings between two spinor spaces.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.mul-Tuple{AdjointBiSpinor, BiSpinor}","page":"API","title":"QEDbase.mul","text":"mul(aBS::AdjointBiSpinor, BS::BiSpinor) -> ComplexF64\n\n\nTensor product of an adjoint with a standard bi-spinor resulting in a scalar.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.mul-Tuple{AdjointBiSpinor, DiracMatrix, BiSpinor}","page":"API","title":"QEDbase.mul","text":"mul(\n    aBS::AdjointBiSpinor,\n    DM::DiracMatrix,\n    BS::BiSpinor\n) -> ComplexF64\n\n\nTensor product of Dirac matrix sandwiched between an adjoint and a standard bi-spinor resulting in a scalar.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.mul-Tuple{AdjointBiSpinor, DiracMatrix}","page":"API","title":"QEDbase.mul","text":"mul(\n    aBS::AdjointBiSpinor,\n    DM::DiracMatrix\n) -> AdjointBiSpinor\n\n\nTensor product of an adjoint bi-spinor with a Dirac matrix resulting in another adjoint bi-spinor.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.mul-Tuple{BiSpinor, AdjointBiSpinor}","page":"API","title":"QEDbase.mul","text":"mul(BS::BiSpinor, aBS::AdjointBiSpinor) -> DiracMatrix\n\n\nTensor product of a standard with an adjoint bi-spinor resulting in a Dirac matrix.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.mul-Tuple{DiracMatrix, BiSpinor}","page":"API","title":"QEDbase.mul","text":"mul(DM::DiracMatrix, BS::BiSpinor) -> BiSpinor\n\n\nTensor product of an Dirac matrix with a standard bi-spinor resulting in another standard bi-spinor.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.mul-Tuple{DiracMatrix, DiracMatrix}","page":"API","title":"QEDbase.mul","text":"mul(DM1::DiracMatrix, DM2::DiracMatrix) -> DiracMatrix\n\n\nTensor product two Dirac matrices resulting in another Dirac matrix.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#Particles","page":"API","title":"Particles","text":"","category":"section"},{"location":"library/api/","page":"API","title":"API","text":"Modules = [QEDbase]\nPages   = [\"particles/particle_direction.jl\", \"particles/particle_spin_pol.jl\", \"particles/particle_spinors.jl\", \"particles/particle_states.jl\", \"particles/particle_types.jl\", \"interfaces/particle_interface.jl\"]\nOrder   = [:type,:function]","category":"page"},{"location":"library/api/#QEDbase.Incoming","page":"API","title":"QEDbase.Incoming","text":"Incoming <: ParticleDirection\n\nConcrete implementation of a ParticleDirection to indicate that a particle is incoming in the context of a given process. Mostly used for dispatch.\n\nnote: ParticleDirection Interface\nBesides being a subtype of ParticleDirection, Incoming hasis_incoming(::Incoming) = true\nis_outgoing(::Incoming) = false\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.Outgoing","page":"API","title":"QEDbase.Outgoing","text":"Outgoing <: ParticleDirection\n\nConcrete implementation of a ParticleDirection to indicate that a particle is outgoing in the context of a given process. Mostly used for dispatch.\n\nnote: ParticleDirection Interface\nBesides being a subtype of ParticleDirection, Outgoing hasis_incoming(::Outgoing) = false\nis_outgoing(::Outgoing) = true\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.ParticleDirection","page":"API","title":"QEDbase.ParticleDirection","text":"Abstract base type for the directions of particles in the context of processes, i.e. either they are incoming or outgoing. Subtypes of this are mostly used for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.AbstractDefinitePolarization","page":"API","title":"QEDbase.AbstractDefinitePolarization","text":"Abstract base type for definite polarizations of BosonLike particles.\n\nConcrete types are PolarizationX and PolarizationY.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.AbstractDefiniteSpin","page":"API","title":"QEDbase.AbstractDefiniteSpin","text":"Abstract base type for definite spins of FermionLike particles.\n\nConcrete types are SpinUp and SpinDown.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.AbstractIndefinitePolarization","page":"API","title":"QEDbase.AbstractIndefinitePolarization","text":"Abstract base type for indefinite polarizations of BosonLike particles.\n\nOne concrete type is AllPolarization.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.AbstractIndefiniteSpin","page":"API","title":"QEDbase.AbstractIndefiniteSpin","text":"Abstract base type for indefinite spins of FermionLike particles.\n\nOne concrete type is AllSpin.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.AbstractPolarization","page":"API","title":"QEDbase.AbstractPolarization","text":"Abstract base type for the polarization of BosonLike particles.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.AbstractSpin","page":"API","title":"QEDbase.AbstractSpin","text":"Abstract base type for the spin of FermionLike particles.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.AbstractSpinOrPolarization","page":"API","title":"QEDbase.AbstractSpinOrPolarization","text":"Abstract base type for the spin or polarization of FermionLike or BosonLike particles, respectively.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.AllPolarization","page":"API","title":"QEDbase.AllPolarization","text":"Concrete type indicating that a BosonLike has an indefinite polarization and the differential cross section calculation should average or sum over all polarizations, depending on the direction (Incoming or Outgoing) of the particle in question.\n\ninfo: Alias\nThere is a built-in alias for AllPolarization:julia> using QEDbase\n\njulia> AllPolarization === AllPol\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.AllSpin","page":"API","title":"QEDbase.AllSpin","text":"Concrete type indicating that a FermionLike has an indefinite spin and the differential cross section calculation should average or sum over all spins, depending on the direction (Incoming or Outgoing) of the particle in question.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.PolarizationX","page":"API","title":"QEDbase.PolarizationX","text":"Concrete type which indicates, that a BosonLike has polarization in x-direction.\n\nnote: Coordinate axes\nThe notion of axes, e.g. x- and y-direction is just to distinguish two orthogonal polarization directions. However, if the three-momentum of the BosonLike is aligned to the z-axis of a coordinate system, the polarization axes define the x- or y-axis, respectively.\n\ninfo: Alias\nThere is a built-in alias for PolarizationX:julia> using QEDbase\n\njulia> PolarizationX === PolX\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.PolarizationY","page":"API","title":"QEDbase.PolarizationY","text":"Concrete type which indicates, that a BosonLike has polarization in y-direction.\n\nnote: Coordinate axes\nThe notion of axes, e.g. x- and y-direction is just to distinguish two orthogonal polarization directions. However, if the three-momentum of the BosonLike is aligned to the z-axis of a coordinate system, the polarization axes define the x- or y-axis, respectively.\n\ninfo: Alias\nThere is a built-in alias for PolarizationY:julia> using QEDbase\n\njulia> PolarizationY === PolY\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.SpinDown","page":"API","title":"QEDbase.SpinDown","text":"Concrete type indicating that a FermionLike has spin-down.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.SpinUp","page":"API","title":"QEDbase.SpinUp","text":"Concrete type indicating that a FermionLike has spin-up.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase._spin_index-Tuple{AbstractDefiniteSpin}","page":"API","title":"QEDbase._spin_index","text":"_spin_index(_::AbstractDefiniteSpin) -> Int64\n\n\nUtility function, which converts subtypes of AbstractDefiniteSpin into an integer representation, e.g. an index:\n\nSpinUp   rightarrow 1\nSpinDown rightarrow 2\n\nThis is useful in the implementation of some of base_state's overloads.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase._as_svec","page":"API","title":"QEDbase._as_svec","text":"_as_svec(x)\n\nAccepts a single object, an SVector of objects or a tuple of objects, and returns them in a single \"layer\" of SVector.\n\nIntended for usage with base_state.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.base_state","page":"API","title":"QEDbase.base_state","text":"    base_state(\n        particle::AbstractParticleType,\n        direction::ParticleDirection,\n        momentum::QEDbase.AbstractFourMomentum,\n        [spin_or_pol::AbstractSpinOrPolarization]\n    )\n\nReturn the base state of a directed on-shell particle with a given four-momentum. For internal usage only.\n\nInput\n\nparticle – the type of the particle, e.g. Electron, Positron, or Photon.\ndirection – the direction of the particle, i.e. Incoming or Outgoing.\nmomentum – the four-momentum of the particle\n[spin_or_pol] – if given, the spin or polarization of the particle, e.g. SpinUp/SpinDown or PolarizationX/PolarizationY.\n\nOutput\n\nThe output type of base_state depends on wether the spin or polarization of the particle passed in is specified or not.\n\nIf spin_or_pol is passed, the output of base_state is\n\nbase_state(::Fermion,     ::Incoming, mom, spin_or_pol) # -> BiSpinor\nbase_state(::AntiFermion, ::Incoming, mom, spin_or_pol) # -> AdjointBiSpinor\nbase_state(::Fermion,     ::Outgoing, mom, spin_or_pol) # -> AdjointBiSpinor\nbase_state(::AntiFermion, ::Outgoing, mom, spin_or_pol) # -> BiSpinor\nbase_state(::Photon,      ::Incoming, mom, spin_or_pol) # -> SLorentzVector{ComplexF64}\nbase_state(::Photon,      ::Outgoing, mom, spin_or_pol) # -> SLorentzVector{ComplexF64}\n\nIf spin_or_pol is of type AllPolarization or AllSpin, the output is an SVector with both spin/polarization alignments:\n\nbase_state(::Fermion,     ::Incoming, mom) # -> SVector{2,BiSpinor}\nbase_state(::AntiFermion, ::Incoming, mom) # -> SVector{2,AdjointBiSpinor}\nbase_state(::Fermion,     ::Outgoing, mom) # -> SVector{2,AdjointBiSpinor}\nbase_state(::AntiFermion, ::Outgoing, mom) # -> SVector{2,BiSpinor}\nbase_state(::Photon,      ::Incoming, mom) # -> SVector{2,SLorentzVector{ComplexF64}}\nbase_state(::Photon,      ::Outgoing, mom) # -> SVector{2,SLorentzVector{ComplexF64}}\n\nExample\n\n\nusing QEDbase\n\nmass = 1.0                              # set electron mass to 1.0\npx,py,pz = rand(3)                      # generate random spatial components\nE = sqrt(px^2 + py^2 + pz^2 + mass^2)   # compute energy, i.e. the electron is on-shell\nmom = SFourMomentum(E, px, py, pz)      # initialize the four-momentum of the electron\n\n# compute the state of an incoming electron with spin = SpinUp\n# note: base_state is not exported!\nelectron_state = base_state(Electron(), Incoming(), mom, SpinUp())\n\n\njulia> using QEDbase\n\njulia> mass = 1.0; px,py,pz = (0.1, 0.2, 0.3); E = sqrt(px^2 + py^2 + pz^2 + mass^2); mom = SFourMomentum(E, px, py, pz)\n4-element SFourMomentum with indices SOneTo(4):\n 1.0677078252031311\n 0.1\n 0.2\n 0.3\n\njulia> electron_state = base_state(Electron(), Incoming(), mom, SpinUp())\n4-element BiSpinor with indices SOneTo(4):\n   1.4379526505428235 + 0.0im\n                  0.0 + 0.0im\n -0.20862995724285552 + 0.0im\n -0.06954331908095185 - 0.1390866381619037im\n\njulia> electron_states = base_state(Electron(), Incoming(), mom, AllSpin())\n2-element StaticArraysCore.SVector{2, BiSpinor} with indices SOneTo(2):\n [1.4379526505428235 + 0.0im, 0.0 + 0.0im, -0.20862995724285552 + 0.0im, -0.06954331908095185 - 0.1390866381619037im]\n [0.0 + 0.0im, 1.4379526505428235 + 0.0im, -0.06954331908095185 + 0.1390866381619037im, 0.20862995724285552 + 0.0im]\n\nnote: Iterator convenience\nThe returned objects of base_state can be consistently wrapped in an SVector for iteration using _as_svec.This way, a loop like the following becomes possible when spin may be definite or indefinite.for state in QEDbase._as_svec(base_state(Electron(), Incoming(), momentum, spin))\n    # ...\nend\n\nnote: Conventions\nFor an incoming fermion with momentum p, we use the explicit formula:u_sigma(p) = fracgamma^mu p_mu + msqrtvert p_0vert  + m eta_sigmawhere the elementary base spinors are given aseta_1 = (1 0 0 0)^T\neta_2 = (0 1 0 0)^TFor an outgoing anti-fermion with momentum p, we use the explicit formula:v_sigma(p) = frac-gamma^mu p_mu + msqrtvert p_0vert  + m chi_sigmawhere the elementary base spinors are given aschi_1 = (0 0 1 0)^T\nchi_2 = (0 0 0 1)^TFor outgoing fermions and incoming anti-fermions with momentum p, the base state is given as the Dirac-adjoint of the respective incoming fermion or outgoing anti-fermion state:overlineu_sigma(p) = u_sigma^dagger gamma^0\noverlinev_sigma(p) = v_sigma^dagger gamma^0where v_sigma is the base state of the respective outgoing anti-fermion.For a photon with four-momentum k^mu = omega (1 cosphi sintheta sinphi sintheta costheta), the two polarization vectors are given asbeginalign*\nepsilon^mu_1 = (0 costheta cosphi costheta sinphi -sintheta)\nepsilon^mu_2 = (0 -sinphi cosphi 0)\nendalign*\n\nwarning: Warning\nIn the current implementation there are no checks built-in, which verify the passed arguments whether they describe on-shell particles, i.e. p*p≈mass^2. Using base_state with off-shell particles will cause unpredictable behavior.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.AbstractParticleType","page":"API","title":"QEDbase.AbstractParticleType","text":"AbstractParticleType <: AbstractParticle\n\nThis is the abstract base type for every species of particles. All functionalities defined on subtypes of AbstractParticleType should be static, i.e. known at compile time.  For adding runtime information, e.g. four-momenta or particle states, to a particle, consider implementing a concrete subtype of AbstractParticle instead, which may have a type parameter P<:AbstractParticleType.\n\nConcrete built-in subtypes of AbstractParticleType are Electron, Positron and Photon.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.AntiBoson","page":"API","title":"QEDbase.AntiBoson","text":"Abstract base type for anti-bosons as distinct from its particle counterpart Boson.\n\nnote: particle interface\nAll subtypes of AntiBoson haveis_boson(::AntiBoson) = true\nis_particle(::AntiBoson) = false\nis_anti_particle(::AntiBoson) = true\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.AntiFermion","page":"API","title":"QEDbase.AntiFermion","text":"Abstract base type for anti-fermions as distinct from its particle counterpart Fermion.\n\nnote: particle interface\nAll subtypes of AntiFermion have is_fermion(::AntiFermion) = true\nis_particle(::AntiFermion) = false\nis_anti_particle(::AntiFermion) = true\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.Boson","page":"API","title":"QEDbase.Boson","text":"Abstract base type for bosons as distinct from its anti-particle counterpart AntiBoson.\n\nnote: particle interface\nAll subtypes of Boson haveis_boson(::Boson) = true\nis_particle(::Boson) = true\nis_anti_particle(::Boson) = false\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.BosonLike","page":"API","title":"QEDbase.BosonLike","text":"Abstract base types for particle species that act like bosons in the sense of particle statistics. \n\nnote: particle interface\nEvery concrete subtype of BosonLike has is_boson(::BosonLike) = true.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.Electron","page":"API","title":"QEDbase.Electron","text":"Concrete type for electrons as a particle species. Mostly used for dispatch. \n\nnote: particle interface\nBesides being a subtype of Fermion, objects of type Electron havemass(::Electron) = 1.0\ncharge(::Electron) = -1.0\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.Fermion","page":"API","title":"QEDbase.Fermion","text":"Abstract base type for fermions as distinct from AntiFermions.\n\nnote: particle interface\nAll subtypes of Fermion haveis_fermion(::Fermion) = true\nis_particle(::Fermion) = true\nis_anti_particle(::Fermion) = false\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.FermionLike","page":"API","title":"QEDbase.FermionLike","text":"Abstract base types for particle species that act like fermions in the sense of particle statistics.\n\nnote: particle interface\nEvery concrete subtype of FermionLike has is_fermion(::FermionLike) = true.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.MajoranaBoson","page":"API","title":"QEDbase.MajoranaBoson","text":"Abstract base type for majorana-bosons, i.e. bosons which are their own anti-particles.\n\nnote: particle interface\nAll subtypes of MajoranaBoson have is_boson(::MajoranaBoson) = true\nis_particle(::MajoranaBoson) = true\nis_anti_particle(::MajoranaBoson) = true\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.MajoranaFermion","page":"API","title":"QEDbase.MajoranaFermion","text":"Abstract base type for majorana-fermions, i.e. fermions which are their own anti-particles.\n\nnote: particle interface\nAll subtypes of MajoranaFermion have is_fermion(::MajoranaFermion) = true\nis_particle(::MajoranaFermion) = true\nis_anti_particle(::MajoranaFermion) = true\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.Photon","page":"API","title":"QEDbase.Photon","text":"Concrete type for the photons as a particle species. Mostly used for dispatch. \n\nnote: particle interface\nBesides being a subtype of MajoranaBoson, Photon hasmass(::Photon) = 0.0\ncharge(::Photon) = 0.0\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.Positron","page":"API","title":"QEDbase.Positron","text":"Concrete type for positrons as a particle species. Mostly used for dispatch. \n\nnote: particle interface\nBesides being a subtype of AntiFermion, objects of type Positron havemass(::Positron) = 1.0\ncharge(::Positron) = 1.0\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.AbstractParticle","page":"API","title":"QEDbase.AbstractParticle","text":"Abstract base type for every type which might be considered a particle in the context of QED.jl. For every (concrete) subtype of AbstractParticle, there are two kinds of interface functions implemented: static functions and property functions.  The static functions provide information on what kind of particle it is (defaults are written in square brackets)\n\n    is_fermion(::AbstractParticle)::Bool [= false]\n    is_boson(::AbstractParticle)::Bool [= false]\n    is_particle(::AbstractParticle)::Bool [= true]\n    is_anti_particle(::AbstractParticle)::Bool [= false]\n\nIf the output of those functions differ from the defaults for a subtype of AbstractParticle, these functions need to be overwritten. The second type of functions define a hard interface for AbstractParticle:\n\n    mass(::AbstractParticle)::Real\n    charge(::AbstractParticle)::Real\n\nThese functions must be implemented in order to have the subtype of AbstractParticle work with the functionalities of QEDprocesses.jl.\n\n\n\n\n\n","category":"type"},{"location":"library/api/#QEDbase.charge","page":"API","title":"QEDbase.charge","text":"charge(::AbstractParticle)::Real\n\nInterface function for particles. Return the electric charge of a particle (in units of the elementary electric charge).\n\nThis needs to be implemented for each concrete subtype of AbstractParticle.\n\n\n\n\n\n","category":"function"},{"location":"library/api/#QEDbase.is_anti_particle-Tuple{AbstractParticle}","page":"API","title":"QEDbase.is_anti_particle","text":"is_anti_particle(_::AbstractParticle) -> Bool\n\n\nInterface function for particles. Return true if the passed subtype of AbstractParticle can be considered an anti particle as distinct from their particle counterpart, and false otherwise. The default implementation of is_anti_particle for every subtype of AbstractParticle will always return false.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.is_boson-Tuple{AbstractParticle}","page":"API","title":"QEDbase.is_boson","text":"is_boson(_::AbstractParticle) -> Bool\n\n\nInterface function for particles. Return true if the passed subtype of AbstractParticle can be considered a boson in the sense of particle statistics, and false otherwise. The default implementation of is_boson for every subtype of AbstractParticle will always return false.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.is_fermion-Tuple{AbstractParticle}","page":"API","title":"QEDbase.is_fermion","text":"is_fermion(_::AbstractParticle) -> Bool\n\n\nInterface function for particles. Return true if the passed subtype of AbstractParticle can be considered a fermion in the sense of particle statistics, and false otherwise. The default implementation of is_fermion for every subtype of AbstractParticle will always return false.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.is_particle-Tuple{AbstractParticle}","page":"API","title":"QEDbase.is_particle","text":"is_particle(_::AbstractParticle) -> Bool\n\n\nInterface function for particles. Return true if the passed subtype of AbstractParticle can be considered a particle as distinct from anti-particles, and false otherwise. The default implementation of is_particle for every subtype of AbstractParticle will always return true.\n\n\n\n\n\n","category":"method"},{"location":"library/api/#QEDbase.mass","page":"API","title":"QEDbase.mass","text":"mass(particle::AbstractParticle)::Real\n\nInterface function for particles. Return the rest mass of a particle (in units of the electron mass).\n\nThis needs to be implemented for each concrete subtype of AbstractParticle.\n\n\n\n\n\n","category":"function"},{"location":"dirac_tensors/#Dirac-tensors","page":"Dirac Tensors","title":"Dirac tensors","text":"","category":"section"},{"location":"dirac_tensors/","page":"Dirac Tensors","title":"Dirac Tensors","text":"We model dirac_tensors as concrete subtypes from AbstractDiracMatrix and AbstractDiracVector, respectively.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QEDbase","category":"page"},{"location":"#QEDbase","page":"Home","title":"QEDbase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QEDbase. This library provides (more or less) simple implementations of Lorentz vectors, Dirac spinors and Dirac matrices. These are usually used in order to do calculations in particle physics, e.g. they are part of the set of Feynman rules for a given quantum field theory (see [1]).","category":"page"},{"location":"four_momenta/#Four-Momenta","page":"Four Momenta","title":"Four Momenta","text":"","category":"section"},{"location":"four_momenta/","page":"Four Momenta","title":"Four Momenta","text":"Within QEDbase, we model four-momenta with a specialized LorentzVector, where the components are forced to be float:","category":"page"},{"location":"four_momenta/","page":"Four Momenta","title":"Four Momenta","text":"    FourMomentum <:AbstractLorentzVector{::Float64}","category":"page"},{"location":"refs/#References","page":"References","title":"References","text":"","category":"section"},{"location":"refs/","page":"References","title":"References","text":"M. E. Peskin and D. V. Schroeder. An Introduction to quantum field theory (Addison-Wesley, Reading, USA, 1995).\n\n\n\n","category":"page"}]
}
