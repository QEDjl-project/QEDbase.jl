var documenterSearchIndex = {"docs":
[{"location":"lorentz_vectors/#Lorentz-vectors","page":"Lorentz Vectors","title":"Lorentz vectors","text":"","category":"section"},{"location":"lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"In oder to model Lorentz vectors, i.e. elements of a Minkowski space, we use a generic type called LorentzVector{T}.","category":"page"},{"location":"library/function_index/#main-index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Pages = [\"api.md\", \"function_index.md\"]","category":"page"},{"location":"library/outline/#API-Outline","page":"Contents","title":"API Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"api.md\", \"function_index.md\"]","category":"page"},{"location":"library/api/#QEDbase","page":"API","title":"QEDbase","text":"","category":"section"},{"location":"library/api/","page":"API","title":"API","text":":warning: Under construction","category":"page"},{"location":"dirac_tensors/#Dirac-tensors","page":"Dirac Tensors","title":"Dirac tensors","text":"","category":"section"},{"location":"dirac_tensors/","page":"Dirac Tensors","title":"Dirac Tensors","text":"We model dirac_tensors as concrete subtypes from AbstractDiracMatrix and AbstractDiracVector, respectively.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QEDbase","category":"page"},{"location":"#QEDbase","page":"Home","title":"QEDbase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QEDbase. This library provides (more or less) simple implementations of Lorentz vectors, Dirac spinors and Dirac matrices. These are usually used in order to do calculations in particle physics, e.g. they are part of the set of Feynman rules for a given quantum field theory (see [1]).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [QEDbase]","category":"page"},{"location":"#QEDbase.AbstractCoordinateSystem","page":"Home","title":"QEDbase.AbstractCoordinateSystem","text":"AbstractCoordinateSystem\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractDefinitePolarization","page":"Home","title":"QEDbase.AbstractDefinitePolarization","text":"Abstract base type for definite polarization of particles with is_boson.\n\nConcrete types are PolarizationX and PolarizationY.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractDefiniteSpin","page":"Home","title":"QEDbase.AbstractDefiniteSpin","text":"Abstract base type for definite spins of particles with is_fermion.\n\nConcrete types are SpinUp and SpinDown.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractDiracMatrix","page":"Home","title":"QEDbase.AbstractDiracMatrix","text":"abstract type AbstractDiracMatrix{T} <: StaticArraysCore.FieldMatrix{4, 4, T}\n\nAbstract type for Dirac matrices, i.e. matrix representations for linear mappings from a spinor space into another.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractDiracVector","page":"Home","title":"QEDbase.AbstractDiracVector","text":"abstract type AbstractDiracVector{T} <: StaticArraysCore.FieldVector{4, T}\n\nAbstract type for Dirac vectors, e.g. four dimensional vectors from a spinor space.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractFourMomentum","page":"Home","title":"QEDbase.AbstractFourMomentum","text":"AbstractFourMomentum\n\nAbstract base type for four-momentas, representing one energy and three spacial components.\n\nAlso see: QEDcore.SFourMomentum, QEDcore.MFourMomentum\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractFrameOfReference","page":"Home","title":"QEDbase.AbstractFrameOfReference","text":"AbstractFrameOfReference\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractInPhaseSpacePoint","page":"Home","title":"QEDbase.AbstractInPhaseSpacePoint","text":"AbstractInPhaseSpacePoint\n\nA partial type specialization on AbstractPhaseSpacePoint which can be used for dispatch in functions requiring only the in channel of the phase space to exist, for example implementations of _incident_flux. No restrictions are imposed on the out-channel, which may or may not exist.\n\nSee also: AbstractOutPhaseSpacePoint\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractIndefinitePolarization","page":"Home","title":"QEDbase.AbstractIndefinitePolarization","text":"Abstract base type for indefinite polarization of particles with is_boson.\n\nOne concrete type is AllPolarization.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractIndefiniteSpin","page":"Home","title":"QEDbase.AbstractIndefiniteSpin","text":"Abstract base type for indefinite spins of particles with is_fermion.\n\nOne concrete type is AllSpin.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractInvalidInputException","page":"Home","title":"QEDbase.AbstractInvalidInputException","text":"Abstract base type for exceptions indicating invalid input. See InvalidInputError for a simple concrete implementation.  Concrete implementations should at least implement \n\n\nBase.showerror(io::IO, err::CustomInvalidError) where {CustomInvalidError<:AbstractInvalidInputException}\n\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractLorentzVector","page":"Home","title":"QEDbase.AbstractLorentzVector","text":"abstract type AbstractLorentzVector{T} <: StaticArraysCore.FieldVector{4, T}\n\nAbstract type to model generic Lorentz vectors, i.e. elements of a minkowski-like space, where the component space is arbitray.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractModelDefinition","page":"Home","title":"QEDbase.AbstractModelDefinition","text":"Abstract base type for all compute model definitions in the context of scattering processes. Every subtype of AbstractModelDefinition is associated with a fundamental interaction.  Therefore, one needs to implement the following soft interface function\n\nfundamental_interaction_type(::AbstractModelDefinition)\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractOutPhaseSpacePoint","page":"Home","title":"QEDbase.AbstractOutPhaseSpacePoint","text":"AbstractOutPhaseSpacePoint\n\nA partial type specialization on AbstractPhaseSpacePoint which can be used for dispatch in functions requiring only the out channel of the phase space to exist. No restrictions are imposed on the in-channel, which may or may not exist.\n\nSee also: AbstractInPhaseSpacePoint\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractParticle","page":"Home","title":"QEDbase.AbstractParticle","text":"Abstract base type for every type which might be considered a particle in the context of QED.jl. For every (concrete) subtype of AbstractParticle, there are two kinds of interface functions implemented: static functions and property functions.  The static functions provide information on what kind of particle it is (defaults are written in square brackets)\n\n    is_fermion(::AbstractParticle)::Bool [= false]\n    is_boson(::AbstractParticle)::Bool [= false]\n    is_particle(::AbstractParticle)::Bool [= true]\n    is_anti_particle(::AbstractParticle)::Bool [= false]\n\nIf the output of those functions differ from the defaults for a subtype of AbstractParticle, these functions need to be overwritten. The second type of functions define a hard interface for AbstractParticle:\n\n    mass(::AbstractParticle)::Real\n    charge(::AbstractParticle)::Real\n\nThese functions must be implemented in order to have the subtype of AbstractParticle work with the functionalities of QEDprocesses.jl.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractParticleStateful","page":"Home","title":"QEDbase.AbstractParticleStateful","text":"AbstractParticleStateful <: QEDbase.AbstractParticle\n\nAbstract base type for the representation of a particle with a state. It requires the following interface functions to be provided:\n\nparticle_direction: Returning the particle's direction.\nparticle_species: Returning the particle's species.\nmomentum: Returning the particle's momentum.\n\nImplementations for is_fermion, is_boson, is_particle, is_anti_particle, is_incoming, is_outgoing, mass, and charge are automatically provided using the interface functions above to fulfill the QEDbase.AbstractParticle interface.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractParticleType","page":"Home","title":"QEDbase.AbstractParticleType","text":"AbstractParticleType <: AbstractParticle\n\nThis is the abstract base type for every species of particles. All functionalities defined on subtypes of AbstractParticleType should be static, i.e. known at compile time.  For adding runtime information, e.g. four-momenta or particle states, to a particle, consider implementing a concrete subtype of AbstractParticle instead, which may have a type parameter P<:AbstractParticleType.\n\nConcrete built-in subtypes of AbstractParticleType are available in QEDcore.jl and should always be singletons..\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractPhaseSpacePoint","page":"Home","title":"QEDbase.AbstractPhaseSpacePoint","text":"AbstractPhaseSpacePoint{PROC, MODEL, PSDEF, IN_PARTICLES, OUT_PARTICLES}\n\nRepresentation of a point in the phase space of a process. It has several template arguments:\n\nPROC <:AbstractProcessDefinition\nMODEL <:AbstractModelDefinition\nPSDEF <:AbstractPhasespaceDefinition\nIN_PARTICLES <:Tuple{Vararg{AbstractParticleStateful}}: The tuple type of all the incoming [AbstractParticleStateful`](@ref)s.\nOUT_PARTICLES <:Tuple{Vararg{AbstractParticleStateful}}: The tuple type of all the outgoing [AbstractParticleStateful`](@ref)s.\n\nThe following interface functions must be provided:\n\nBase.getindex(psp::AbstractPhaseSpacePoint, dir::ParticleDirection, n::Int): Return the nth AbstractParticleStateful of the given direction. Throw BoundsError for invalid indices.\nparticles(psp::AbstractPhaseSpacePoint, dir::ParticleDirection): Return the particle tuple (type IN_PARTICLES or OUT_PARTICLES depending on dir)\nprocess: Return the process.\nmodel: Return the model.\nphase_space_definition: Return the phase space definition.\n\nFrom this, the following functions are automatically derived:\n\nmomentum(psp::AbstractPhaseSpacePoint, dir::ParticleDirection, n::Int): Return the momentum of the nth AbstractParticleStateful of the given direction.\nmomenta(psp::PhaseSpacePoint, ::ParticleDirection): Return a Tuple of all the momenta of the given direction.\n\nFurthermore, an implementation of an AbstractPhaseSpacePoint has to verify on construction that it is valid, i.e., the following conditions are fulfilled:\n\nIN_PARTICLES must match incoming_particles(::PROC) in length, order, and type or be an empty Tuple.\nOUT_PARTICLES must match the outgoing_particles(::PROC) in length, order, and type, or be an empty Tuple.\nIN_PARTICLES and OUT_PARTICLES may not both be empty.\n\nIf IN_PARTICLES is non-empty, AbstractPhaseSpacePoint <: AbstractInPhaseSpacePoint is true. Likewise, if OUT_PARTICLES is non-empty, AbstractPhaseSpacePoint <: AbstractOutPhaseSpacePoint is true. Consequently, if both IN_PARTICLES and OUT_PARTICLES are non-empty, both <: statements are true.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractPhasespaceDefinition","page":"Home","title":"QEDbase.AbstractPhasespaceDefinition","text":"AbstractPhasespaceDefinition\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractPolarization","page":"Home","title":"QEDbase.AbstractPolarization","text":"Abstract base type for the polarization of particles with is_boson.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractProcessDefinition","page":"Home","title":"QEDbase.AbstractProcessDefinition","text":"Abstract base type for definitions of scattering processes. It is the root type for the  process interface, which assumes that every subtype of AbstractProcessDefinition implements at least \n\nincoming_particles(proc_def::AbstractProcessDefinition)\noutgoing_particles(proc_def::AbstractProcessDefinition)\n\nwhich return a tuple of the incoming and outgoing particles, respectively.\n\nFurthermore, to calculate scattering probabilities and differential cross sections, the following  interface functions need to be implemented for every combination of CustomProcess<:AbstractProcessDefinition,  CustomModel<:AbstractModelDefinition, and CustomPhasespaceDefinition<:AbstractPhasespaceDefinition.\n\n    _incident_flux(psp::InPhaseSpacePoint{CustomProcess,CustomModel})\n\n    _matrix_element(psp::PhaseSpacePoint{CustomProcess,CustomModel})\n\n    _averaging_norm(proc::CustomProcess)\n\n    _is_in_phasespace(psp::PhaseSpacePoint{CustomProcess,CustomModel})\n\n    _phase_space_factor(psp::PhaseSpacePoint{CustomProcess,CustomModel,CustomPhasespaceDefinition})\n\nOptional is the implementation of \n\n\n    _total_probability(psp::PhaseSpacePoint{CustomProcess,CustomModel,CustomPhasespaceDefinition})\n\n\nto enable the calculation of total probabilities and cross sections.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractSpin","page":"Home","title":"QEDbase.AbstractSpin","text":"Abstract base type for the spin of particles with is_fermion.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AbstractSpinOrPolarization","page":"Home","title":"QEDbase.AbstractSpinOrPolarization","text":"Abstract base type for the spin or polarization of particles with is_fermion or is_boson, respectively.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AllPolarization","page":"Home","title":"QEDbase.AllPolarization","text":"Concrete type indicating that a particle with is_boson has an indefinite polarization and the differential cross section calculation should average or sum over all polarizations, depending on the direction (Incoming or Outgoing) of the particle in question.\n\njulia> using QEDbase\n\njulia> AllPol()\nall polarizations\n\ninfo: Alias\nThere is a built-in alias for AllPolarization:julia> using QEDbase\n\njulia> AllPolarization === AllPol\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.AllSpin","page":"Home","title":"QEDbase.AllSpin","text":"Concrete type indicating that a particle with is_fermion has an indefinite spin and the differential cross section calculation should average or sum over all spins, depending on the direction (Incoming or Outgoing) of the particle in question.\n\njulia> using QEDbase\n\njulia> AllSpin()\nall spins\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.Incoming","page":"Home","title":"QEDbase.Incoming","text":"Incoming <: ParticleDirection\n\nConcrete implementation of a ParticleDirection to indicate that a particle is incoming in the context of a given process. Mostly used for dispatch.\n\njulia> using QEDbase\n\njulia> Incoming()\nincoming\n\nnote: ParticleDirection Interface\nBesides being a subtype of ParticleDirection, Incoming hasis_incoming(::Incoming) = true\nis_outgoing(::Incoming) = false\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.InvalidInputError","page":"Home","title":"QEDbase.InvalidInputError","text":"InvalidInputError(msg::String)\n\nException which is thrown if a function input is invalid.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.Outgoing","page":"Home","title":"QEDbase.Outgoing","text":"Outgoing <: ParticleDirection\n\nConcrete implementation of a ParticleDirection to indicate that a particle is outgoing in the context of a given process. Mostly used for dispatch.\n\njulia> using QEDbase\n\njulia> Outgoing()\noutgoing\n\nnote: ParticleDirection Interface\nBesides being a subtype of ParticleDirection, Outgoing hasis_incoming(::Outgoing) = false\nis_outgoing(::Outgoing) = true\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.ParticleDirection","page":"Home","title":"QEDbase.ParticleDirection","text":"Abstract base type for the directions of particles in the context of processes, i.e. either they are incoming or outgoing. Subtypes of this are mostly used for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.PolarizationX","page":"Home","title":"QEDbase.PolarizationX","text":"Concrete type which indicates, that a particle with is_boson has polarization in x-direction.\n\njulia> using QEDbase\n\njulia> PolX()\nx-polarized\n\nnote: Coordinate axes\nThe notion of axes, e.g. x- and y-direction is just to distinguish two orthogonal polarization directions. However, if the three-momentum of the particle with is_boson is aligned to the z-axis of a coordinate system, the polarization axes define the x- or y-axis, respectively.\n\ninfo: Alias\nThere is a built-in alias for PolarizationX:julia> using QEDbase\n\njulia> PolarizationX === PolX\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.PolarizationY","page":"Home","title":"QEDbase.PolarizationY","text":"Concrete type which indicates, that a particle with is_boson has polarization in y-direction.\n\njulia> using QEDbase\n\njulia> PolY()\ny-polarized\n\nnote: Coordinate axes\nThe notion of axes, e.g. x- and y-direction is just to distinguish two orthogonal polarization directions. However, if the three-momentum of the particle with is_boson is aligned to the z-axis of a coordinate system, the polarization axes define the x- or y-axis, respectively.\n\ninfo: Alias\nThere is a built-in alias for PolarizationY:julia> using QEDbase\n\njulia> PolarizationY === PolY\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.RegistryError","page":"Home","title":"QEDbase.RegistryError","text":"struct RegistryError <: Exception\n\nException raised, if a certain type target_type can not be registed for a certain interface, since there needs the function func to be impleemnted.\n\nFields\n\nfunc::Function\ntarget_type::Any\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.SpinDown","page":"Home","title":"QEDbase.SpinDown","text":"Concrete type indicating that a particle with is_fermion has spin-down.\n\njulia> using QEDbase\n\njulia> SpinDown()\nspin down\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.SpinUp","page":"Home","title":"QEDbase.SpinUp","text":"Concrete type indicating that a particle with is_fermion has spin-up.\n\njulia> using QEDbase\n\njulia> SpinUp()\nspin up\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase.UnknownDirection","page":"Home","title":"QEDbase.UnknownDirection","text":"UnknownDirection <: ParticleDirection\n\nConcrete implementation of a ParticleDirection to indicate that a particle has an unknown direction. This can mean that a specific direction does not make sense in the given context, that the direction is unavailable, or that it is unnecessary.\n\njulia> using QEDbase\n\njulia> UnknownDirection()\nunknown direction\n\nnote: ParticleDirection Interface\nBesides being a subtype of ParticleDirection, UnknownDirection hasis_incoming(::UnknownDirection) = false\nis_outgoing(::UnknownDirection) = false\n\n\n\n\n\n","category":"type"},{"location":"#QEDbase._as_svec","page":"Home","title":"QEDbase._as_svec","text":"_as_svec(x)\n\nAccepts a single object, an SVector of objects or a tuple of objects, and returns them in a single \"layer\" of SVector.\n\nUseful with base_state.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase._averaging_norm","page":"Home","title":"QEDbase._averaging_norm","text":"_averaging_norm(proc::AbstractProcessDefinition)\n\nInterface function, which returns a normalization for the averaging of the squared matrix elements over spins and polarizations. \n\n\n\n\n\n","category":"function"},{"location":"#QEDbase._generate_incoming_momenta","page":"Home","title":"QEDbase._generate_incoming_momenta","text":"_generate_incoming_momenta(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n    phase_space_def::AbstractPhasespaceDefinition,\n    in_phase_space::NTuple{N,T},\n) where {N,T<:Real}\n\nInterface function to generate the four-momenta of the incoming particles from coordinates for a given phase-space definition.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase._generate_momenta-Union{Tuple{T}, Tuple{M}, Tuple{N}, Tuple{AbstractProcessDefinition, AbstractModelDefinition, AbstractPhasespaceDefinition, Tuple{Vararg{T, N}}, Tuple{Vararg{T, M}}}} where {N, M, T<:Real}","page":"Home","title":"QEDbase._generate_momenta","text":"_generate_momenta(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n    phase_space_def::AbstractPhasespaceDefinition,\n    in_phase_space::NTuple{N,T},\n    out_phase_space::NTuple{M,T},\n) where {N,M,T<:Real}\n\nReturn four-momenta for incoming and outgoing particles for given coordinate based phase-space points. \n\n\n\n\n\n","category":"method"},{"location":"#QEDbase._generate_outgoing_momenta","page":"Home","title":"QEDbase._generate_outgoing_momenta","text":"_generate_outgoing_momenta(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n    phase_space_def::AbstractPhasespaceDefinition,\n    in_phase_space::NTuple{N,T},\n    out_phase_space::NTuple{M,T},\n) where {N,M,T<:Real}\n\nInterface function to generate the four-momenta of the outgoing particles from coordinates for a given phase-space definition.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase._hasmethod_registry-Union{Tuple{T}, Tuple{Function, Type{T}}} where T","page":"Home","title":"QEDbase._hasmethod_registry","text":"_hasmethod_registry(fun, _)\n\n\nWrapper around Base.hasmethod with a more meaningful error message in the context of function registration.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase._incident_flux","page":"Home","title":"QEDbase._incident_flux","text":"_incident_flux(in_psp::InPhaseSpacePoint{PROC,MODEL}) where {\n    PROC <: AbstractProcessDefinition,\n    MODEL <: AbstractModelDefinition,\n}\n\nInterface function which returns the incident flux of the given scattering process for a given InPhaseSpacePoint.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase._is_in_phasespace","page":"Home","title":"QEDbase._is_in_phasespace","text":"_is_in_phasespace(PhaseSpacePoint{PROC,MODEL}) where {\n    PROC <: AbstractProcessDefinition,\n    MODEL <: AbstractModelDefinition,\n}\n\nInterface function which returns true if the combination of the given incoming and outgoing phase space is physical, i.e. all momenta are on-shell and some sort of energy-momentum conservation holds.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase._matrix_element","page":"Home","title":"QEDbase._matrix_element","text":"_matrix_element(PhaseSpacePoint{PROC,MODEL}) where {\n    PROC <: AbstractProcessDefinition,\n    MODEL <: AbstractModelDefinition,\n}\n\nInterface function which returns a tuple of scattering matrix elements for each spin and polarization combination of proc. \n\n\n\n\n\n","category":"function"},{"location":"#QEDbase._phase_space_factor","page":"Home","title":"QEDbase._phase_space_factor","text":"_phase_space_factor(PhaseSpacePoint{PROC,MODEL,PSDEF}) where {\n    PROC <: AbstractProcessDefinition,\n    MODEL <: AbstractModelDefinition\n    PSDEF <: AbstractPhasespaceDefinition,\n}\n\nInterface function, which returns the pre-differential factor of the invariant phase space intergral measure. \n\nnote: Convention\nIt is assumed, that this function returns the value of mathrmdPi_n= prod_i=1^N fracmathrmd^3p_i(2pi)^3 2 p_i^0 H(P_t p_1 dots p_N)\n\nwhere H(dots) is a characteristic function (or distribution) which constrains the phase space, e.g. delta^(4)(P_t - sum_i p_i).  \n\n\n\n\n\n","category":"function"},{"location":"#QEDbase._spin_index-Tuple{AbstractDefiniteSpin}","page":"Home","title":"QEDbase._spin_index","text":"_spin_index(_::AbstractDefiniteSpin) -> Int64\n\n\nUtility function, which converts subtypes of AbstractDefiniteSpin into an integer representation, e.g. an index:\n\nSpinUp   rightarrow 1\nSpinDown rightarrow 2\n\nThis is useful in the implementation of some of base_state's overloads.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase._total_probability","page":"Home","title":"QEDbase._total_probability","text":"_total_probability(in_psp::InPhaseSpacePoint{PROC,MODEL}) where {\n    PROC <: AbstractProcessDefinition,\n    MODEL <: AbstractModelDefinition,\n}\n\nInterface function for the combination of a scattering process and a physical model. Return the total of a  given process and model for a passed InPhaseSpacePoint.\n\nnote: total cross section\nGiven an implementation of this method and _incident_flux, the respective function for the total cross section total_cross_section is also available.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.assert_onshell-Tuple{AbstractLorentzVector, Real}","page":"Home","title":"QEDbase.assert_onshell","text":"assert_onshell(mom, mass)\n\n\nAssertion if a FourMomentum mom is on-shell w.r.t a given mass mass.\n\nnote: See also\nThe precision of this functions is explained in isonshell.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.base_state","page":"Home","title":"QEDbase.base_state","text":"    base_state(\n        particle::AbstractParticleType,\n        direction::ParticleDirection,\n        momentum::QEDbase.AbstractFourMomentum,\n        [spin_or_pol::AbstractSpinOrPolarization]\n    )\n\nReturn the base state of a directed on-shell particle with a given four-momentum. For internal usage only.\n\nInput\n\nparticle – the type of the particle, i.e., an instance of an AbstractParticleType, e.g. QEDcore.Electron, QEDcore.Positron, or QEDcore.Photon.\ndirection – the direction of the particle, i.e. Incoming or Outgoing.\nmomentum – the four-momentum of the particle\n[spin_or_pol] – if given, the spin or polarization of the particle, e.g. SpinUp/SpinDown or PolarizationX/PolarizationY.\n\nOutput\n\nThe output type of base_state depends on wether the spin or polarization of the particle passed in is specified or not.\n\nIf spin_or_pol is passed, the output of base_state is\n\nbase_state(::Fermion,     ::Incoming, mom, spin_or_pol) # -> BiSpinor\nbase_state(::AntiFermion, ::Incoming, mom, spin_or_pol) # -> AdjointBiSpinor\nbase_state(::Fermion,     ::Outgoing, mom, spin_or_pol) # -> AdjointBiSpinor\nbase_state(::AntiFermion, ::Outgoing, mom, spin_or_pol) # -> BiSpinor\nbase_state(::Photon,      ::Incoming, mom, spin_or_pol) # -> SLorentzVector{ComplexF64}\nbase_state(::Photon,      ::Outgoing, mom, spin_or_pol) # -> SLorentzVector{ComplexF64}\n\nIf spin_or_pol is of type AllPolarization or AllSpin, the output is an SVector with both spin/polarization alignments:\n\nbase_state(::Fermion,     ::Incoming, mom) # -> SVector{2,BiSpinor}\nbase_state(::AntiFermion, ::Incoming, mom) # -> SVector{2,AdjointBiSpinor}\nbase_state(::Fermion,     ::Outgoing, mom) # -> SVector{2,AdjointBiSpinor}\nbase_state(::AntiFermion, ::Outgoing, mom) # -> SVector{2,BiSpinor}\nbase_state(::Photon,      ::Incoming, mom) # -> SVector{2,SLorentzVector{ComplexF64}}\nbase_state(::Photon,      ::Outgoing, mom) # -> SVector{2,SLorentzVector{ComplexF64}}\n\nExample\n\nusing QEDbase\n\nmass = 1.0                              # set electron mass to 1.0\npx,py,pz = rand(3)                      # generate random spatial components\nE = sqrt(px^2 + py^2 + pz^2 + mass^2)   # compute energy, i.e. the electron is on-shell\nmom = SFourMomentum(E, px, py, pz)      # initialize the four-momentum of the electron\n\n# compute the state of an incoming electron with spin = SpinUp\n# note: base_state is not exported!\nelectron_state = base_state(QEDcore.Electron(), Incoming(), mom, SpinUp())\n\njulia> using QEDbase; using QEDcore\n\njulia> mass = 1.0; px,py,pz = (0.1, 0.2, 0.3); E = sqrt(px^2 + py^2 + pz^2 + mass^2); mom = SFourMomentum(E, px, py, pz)\n4-element SFourMomentum with indices SOneTo(4):\n 1.0677078252031311\n 0.1\n 0.2\n 0.3\n\njulia> electron_state = base_state(Electron(), Incoming(), mom, SpinUp())\n4-element BiSpinor with indices SOneTo(4):\n   1.4379526505428235 + 0.0im\n                  0.0 + 0.0im\n -0.20862995724285552 + 0.0im\n -0.06954331908095185 - 0.1390866381619037im\n\njulia> electron_states = base_state(Electron(), Incoming(), mom, AllSpin())\n2-element StaticArraysCore.SVector{2, BiSpinor} with indices SOneTo(2):\n [1.4379526505428235 + 0.0im, 0.0 + 0.0im, -0.20862995724285552 + 0.0im, -0.06954331908095185 - 0.1390866381619037im]\n [0.0 + 0.0im, 1.4379526505428235 + 0.0im, -0.06954331908095185 + 0.1390866381619037im, 0.20862995724285552 + 0.0im]\n\nnote: Iterator convenience\nThe returned objects of base_state can be consistently wrapped in an SVector for iteration using _as_svec.This way, a loop like the following becomes possible when spin may be definite or indefinite.for state in QEDbase._as_svec(base_state(Electron(), Incoming(), momentum, spin))\n    # ...\nend\n\nnote: Conventions\nFor an incoming fermion with momentum p, we use the explicit formula:u_sigma(p) = fracgamma^mu p_mu + msqrtvert p_0vert  + m eta_sigmawhere the elementary base spinors are given aseta_1 = (1 0 0 0)^T\neta_2 = (0 1 0 0)^TFor an outgoing anti-fermion with momentum p, we use the explicit formula:v_sigma(p) = frac-gamma^mu p_mu + msqrtvert p_0vert  + m chi_sigmawhere the elementary base spinors are given aschi_1 = (0 0 1 0)^T\nchi_2 = (0 0 0 1)^TFor outgoing fermions and incoming anti-fermions with momentum p, the base state is given as the Dirac-adjoint of the respective incoming fermion or outgoing anti-fermion state:overlineu_sigma(p) = u_sigma^dagger gamma^0\noverlinev_sigma(p) = v_sigma^dagger gamma^0where v_sigma is the base state of the respective outgoing anti-fermion.For a photon with four-momentum k^mu = omega (1 cosphi sintheta sinphi sintheta costheta), the two polarization vectors are given asbeginalign*\nepsilon^mu_1 = (0 costheta cosphi costheta sinphi -sintheta)\nepsilon^mu_2 = (0 -sinphi cosphi 0)\nendalign*\n\nwarning: Warning\nIn the current implementation there are no checks built-in, which verify the passed arguments whether they describe on-shell particles, i.e. p*p≈mass^2. Using base_state with off-shell particles will cause unpredictable behavior.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.charge","page":"Home","title":"QEDbase.charge","text":"charge(::AbstractParticle)::Real\n\nInterface function for particles. Return the electric charge of a particle (in units of the elementary electric charge).\n\nThis needs to be implemented for each concrete subtype of AbstractParticle.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.differential_cross_section-Tuple{AbstractPhaseSpacePoint}","page":"Home","title":"QEDbase.differential_cross_section","text":"differential_cross_section(phase_space_point::PhaseSpacePoint)\n\nIf the given phase spaces are physical, return differential cross section evaluated on a phase space point. Zero otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.differential_probability-Tuple{AbstractPhaseSpacePoint}","page":"Home","title":"QEDbase.differential_probability","text":"differential_probability(phase_space_point::AbstractPhaseSpacePoint)\n\nIf the given phase spaces are physical, return differential probability evaluated on a phase space point. Zero otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.fundamental_interaction_type","page":"Home","title":"QEDbase.fundamental_interaction_type","text":"fundamental_interaction_type(models_def::AbstractModelDefinition)\n\nReturn the fundamental interaction associated with the passed model definition.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getBeta-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getBeta","text":"getBeta(lv)\n\nReturn magnitude of the beta vector for a given LorentzVectorLike, i.e. the magnitude of the LorentzVectorLike divided by its 0-component.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to sqrt(px^2 + py^2 + pz^2)/E.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getCosPhi-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getCosPhi","text":"getCosPhi(lv)\n\nReturn the cosine of the phi angle for a given LorentzVectorLike.\n\nnote: Note\nThis is an equivalent but faster version of cos(getPhi(lv)); see getPhi.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getCosTheta-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getCosTheta","text":"getCosTheta(lv)\n\nReturn the cosine of the theta angle for a given LorentzVectorLike.\n\nnote: Note\nThis is an equivalent but faster version of cos(getTheta(lv)); see getTheta.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getE-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getE","text":"getE(lv)\n\nReturn the energy component of a given LorentzVectorLike, i.e. its 0-component. \n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to E.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getEnergy","page":"Home","title":"QEDbase.getEnergy","text":"Function alias for getE.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getGamma-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getGamma","text":"getGamma(lv)\n\nReturn the relativistic gamma factor for a given LorentzVectorLike, i.e. the inverse square root of one minus the beta vector squared.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike with beta vector β, this is equivalent to 1/sqrt(1- β^2).\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getInvariantMass-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getInvariantMass","text":"getInvariantMass(lv)\n\nReturn the the invariant mass of a given LorentzVectorLike, i.e. the square root of the minkowski dot with itself. \n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to sqrt(t^2 - (x^2 + y^2 + z^2)).\n\nnote: Note\nIf the squared invariant mass m2 is negative, -sqrt(-m2) is returned. \n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getInvariantMass2-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getInvariantMass2","text":"getInvariantMass2(lv)\n\nReturn the squared invariant mass of a given LorentzVectorLike, i.e. the minkowski dot with itself. \n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to t^2 - (x^2 + y^2 + z^2). \n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getMag","page":"Home","title":"QEDbase.getMag","text":"Functiom alias for getMagnitude.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getMag2","page":"Home","title":"QEDbase.getMag2","text":"Functiom alias for getMagnitude2.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getMagnitude-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getMagnitude","text":"getMagnitude(lv)\n\nReturn the magnitude of a given LorentzVectorLike, i.e. the euklidian norm spatial components. \n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to sqrt(x^2 + y^2 + z^2).\n\nwarning: Warning\nThis function differs from a similar function for the TLorentzVector used in the famous ROOT library.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getMagnitude2-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getMagnitude2","text":"getMagnitude2(lv)\n\nReturn the square of the magnitude of a given LorentzVectorLike, i.e. the sum of the squared spatial components. \n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to x^2+ y^2 + z^2.\n\nwarning: Warning\nThis function differs from a similar function for the TLorentzVector used in the famous ROOT library.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getMass","page":"Home","title":"QEDbase.getMass","text":"Function alias for getInvariantMass.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getMass2","page":"Home","title":"QEDbase.getMass2","text":"Function alias for getInvariantMass2\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getMinus-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getMinus","text":"getMinus(lv)\n\nReturn the minus component for a given LorentzVectorLike in light-cone coordinates.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to (E-pz)/2.\n\nnote: Note\nThe light-cone coordinates are defined w.r.t. to the 3-axis.\n\nwarning: Warning\nThe definition `p^- := (E - p_z)/2 differs from the usual definition of light-cone coordinates in general relativity.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getMt","page":"Home","title":"QEDbase.getMt","text":"Function alias for getTransverseMass\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getMt2","page":"Home","title":"QEDbase.getMt2","text":"Function alias for getTransverseMass2\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getPerp","page":"Home","title":"QEDbase.getPerp","text":"Function alias for getTransverseMomentum.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getPerp2","page":"Home","title":"QEDbase.getPerp2","text":"Function alias for getTransverseMomentum2.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getPhi-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getPhi","text":"getPhi(lv)\n\nReturn the phi angle for a given LorentzVectorLike, i.e. the azimuthal angle of its spatial components in spherical coordinates.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to atan(py,px).\n\nnote: Note\nThe spherical coordinates are defined w.r.t. to the 3-axis. \n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getPlus-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getPlus","text":"getPlus(lv)\n\nReturn the plus component for a given LorentzVectorLike in light-cone coordinates.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to (E+pz)/2.\n\nnote: Note\nThe light-cone coordinates are defined w.r.t. to the 3-axis.\n\nwarning: Warning\nThe definition `p^+ := (E + p_z)/2 differs from the usual definition of light-cone coordinates in general relativity.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getPt","page":"Home","title":"QEDbase.getPt","text":"Function alias for getTransverseMomentum.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getPt2","page":"Home","title":"QEDbase.getPt2","text":"Function alias for getTransverseMomentum2.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getPx-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getPx","text":"getPx(lv)\n\nReturn the p_x component of a given LorentzVectorLike, i.e. its 1-component. \n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to px.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getPy-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getPy","text":"getPy(lv)\n\nReturn the p_y component of a given LorentzVectorLike, i.e. its 2-component. \n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to py.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getPz-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getPz","text":"getPz(lv)\n\nReturn the p_z component of a given LorentzVectorLike, i.e. its 3-component. \n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to pz.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getRapidity-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getRapidity","text":"getRapidity(lv)\n\nReturn the rapidity for a given LorentzVectorLike.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to 0.5*log((E+pz)/(E-pz)).\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis. \n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getRho","page":"Home","title":"QEDbase.getRho","text":"Function alias for getMagnitude\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getRho2","page":"Home","title":"QEDbase.getRho2","text":"Function alias for getMagnitude2\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getSinPhi-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getSinPhi","text":"getSinPhi(lv)\n\nReturn the sine of the phi angle for a given LorentzVectorLike.\n\nnote: Note\nThis is an equivalent but faster version of sin(getPhi(lv)); see getPhi.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getT","page":"Home","title":"QEDbase.getT","text":"getT(lv)\n\nReturn the 0-component of a given LorentzVectorLike.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to t.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getTheta-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getTheta","text":"getTheta(lv)\n\nReturn the theta angle for a given LorentzVectorLike, i.e. the polar angle of its spatial components in spherical coordinates.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike with magnitude rho, this is equivalent to arccos(pz/rho), which is also equivalent to arctan(sqrt(px^2+py^2)/pz).\n\nnote: Note\nThe spherical coordinates are defined w.r.t. to the 3-axis. \n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getTransverseMass-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getTransverseMass","text":"getTransverseMass(lv)\n\nReturn the transverse momentum for a given LorentzVectorLike, i.e. the square root of its squared transverse mass.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to sqrt(E^2 - pz^2).\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis. \n\nnote: Note\nIf the squared transverse mass mT2 is negative, -sqrt(-mT2) is returned.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getTransverseMass2-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getTransverseMass2","text":"getTransverseMass2(lv)\n\nReturn the squared transverse mass for a given LorentzVectorLike, i.e. the difference of its squared 0- and 3-component.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to E^2 - pz^2.\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis. \n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getTransverseMomentum-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getTransverseMomentum","text":"getTransverseMomentum(lv)\n\nReturn the transverse momentum for a given LorentzVectorLike, i.e. the magnitude of its transverse components.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to sqrt(px^2 + py^2).\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis. \n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getTransverseMomentum2-Union{Tuple{T}, Tuple{Type{QEDbase.IsLorentzVectorLike{T}}, T}} where T","page":"Home","title":"QEDbase.getTransverseMomentum2","text":"getTransverseMomentum2(lv)\n\nReturn the squared transverse momentum for a given LorentzVectorLike, i.e. the sum of its squared 1- and 2-component.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to px^2 + py^2.\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis. \n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.getX","page":"Home","title":"QEDbase.getX","text":"getX(lv)\n\nReturn the 1-component of a given LorentzVectorLike.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to x.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getY","page":"Home","title":"QEDbase.getY","text":"getY(lv)\n\nReturn the 2-component of a given LorentzVectorLike.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to y.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.getZ","page":"Home","title":"QEDbase.getZ","text":"getZ(lv)\n\nReturn the 3-component of a given LorentzVectorLike.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to z.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.in_phase_space_dimension","page":"Home","title":"QEDbase.in_phase_space_dimension","text":"in_phase_space_dimension(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n)\n\nTBW\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.incoming_particles","page":"Home","title":"QEDbase.incoming_particles","text":"incoming_particles(proc_def::AbstractProcessDefinition)\n\nInterface function for scattering processes. Return a tuple of the incoming particles for the given process definition. This function needs to be given to implement the scattering process interface.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.is_anti_particle-Tuple{AbstractParticle}","page":"Home","title":"QEDbase.is_anti_particle","text":"is_anti_particle(_::AbstractParticle) -> Bool\n\n\nInterface function for particles. Return true if the passed subtype of AbstractParticle can be considered an anti particle as distinct from their particle counterpart, and false otherwise. The default implementation of is_anti_particle for every subtype of AbstractParticle will always return false.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.is_boson-Tuple{AbstractParticle}","page":"Home","title":"QEDbase.is_boson","text":"is_boson(_::AbstractParticle)\n\n\nInterface function for particles. Return true if the passed subtype of AbstractParticle can be considered a boson in the sense of particle statistics, and false otherwise. The default implementation of is_boson for every subtype of AbstractParticle will always return false.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.is_fermion-Tuple{AbstractParticle}","page":"Home","title":"QEDbase.is_fermion","text":"is_fermion(_::AbstractParticle) -> Bool\n\n\nInterface function for particles. Return true if the passed subtype of AbstractParticle can be considered a fermion in the sense of particle statistics, and false otherwise. The default implementation of is_fermion for every subtype of AbstractParticle will always return false.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.is_incoming","page":"Home","title":"QEDbase.is_incoming","text":"is_incoming(dir::ParticleDirection)\nis_incoming(particle::AbstractParticleStateful)\n\nConvenience function that returns true for Incoming and incoming AbstractParticleStateful and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.is_outgoing","page":"Home","title":"QEDbase.is_outgoing","text":"is_outgoing(dir::ParticleDirection)\nis_outgoing(particle::AbstractParticleStateful)\n\nConvenience function that returns true for Outgoing and outgoing AbstractParticleStateful and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.is_particle-Tuple{AbstractParticle}","page":"Home","title":"QEDbase.is_particle","text":"is_particle(_::AbstractParticle) -> Bool\n\n\nInterface function for particles. Return true if the passed subtype of AbstractParticle can be considered a particle as distinct from anti-particles, and false otherwise. The default implementation of is_particle for every subtype of AbstractParticle will always return true.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.isonshell-Union{Tuple{T}, Tuple{AbstractLorentzVector{T}, Real}} where T<:Real","page":"Home","title":"QEDbase.isonshell","text":"isonshell(mom, mass)\n\n\nOn-shell check of a given four-momentum mom w.r.t. a given mass mass. \n\nnote: Precision\nFor AbstactFourMomentum, the element type is fixed to Float64, limiting the precision of comparisons between elements. The current implementation has been tested within the boundaries for energy scales E with 1e-9 <= E <= 1e5.  In those bounds, the mass error, which is correctly detected as off-shell, is 1e-4 times the mean value of the components, but has at most the value 0.01, e.g. at the high energy end. The energy scales correspond to 0.5 meV for the lower bound and 50 GeV for the upper bound.\n\ntodo: FourMomenta with real entries\nif AbstractFourMomentum is updated to elementtypes T<:Real, the AbstractLorentzVector should be updated with the AbstractFourMomentum.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.mass","page":"Home","title":"QEDbase.mass","text":"mass(particle::AbstractParticle)::Real\n\nInterface function for particles. Return the rest mass of a particle (in units of the electron mass).\n\nThis needs to be implemented for each concrete subtype of AbstractParticle.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.mdot","page":"Home","title":"QEDbase.mdot","text":"Function alias for minkowski_dot.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.minkowski_dot-Union{Tuple{T2}, Tuple{T1}, Tuple{Type{QEDbase.IsLorentzVectorLike{T1}}, T1, T2}} where {T1, T2}","page":"Home","title":"QEDbase.minkowski_dot","text":"minkowski_dot(v1,v2)\n\nReturn the Minkowski dot product of two LorentzVectorLike. \n\nexample: Example\nIf (t1,x1,y1,z1) and (t2,x2,y2,z2) are two LorentzVectorLike, this is equivalent to t1*t2 - (x1*x2 + y1*y2 + z1*z2)\n\nnote: Note\nWe use the mostly minus metric.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.model","page":"Home","title":"QEDbase.model","text":"model(psp::AbstractPhaseSpacePoint)\n\nReturn the phase space point's set model.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.momenta-Tuple{AbstractPhaseSpacePoint, Incoming}","page":"Home","title":"QEDbase.momenta","text":"momenta(psp::AbstractPhaseSpacePoint, ::ParticleDirection)\n\nReturn a Tuple of all the particles' momenta for the given ParticleDirection.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.momentum","page":"Home","title":"QEDbase.momentum","text":"momentum(part::AbstractParticleStateful)\n\nInterface function that must return the particle's AbstractFourMomentum.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.momentum-Tuple{AbstractPhaseSpacePoint, ParticleDirection, AbstractParticleType, Int64}","page":"Home","title":"QEDbase.momentum","text":"momentum(psp::AbstractPhaseSpacePoint, dir::ParticleDirection, species::AbstractParticleType, n::Int)\n\nReturns the momentum of the nth particle in the given AbstractPhaseSpacePoint which has direction dir and species species. If n is outside the valid range for this phase space point, a BoundsError is thrown.\n\nnote: Note\nThis function accepts n as an Int value. If n is a compile-time constant (for example, a literal 1 or 2), you can use Val(n) instead to call a zero overhead version of this function.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.momentum-Tuple{AbstractPhaseSpacePoint, ParticleDirection, AbstractParticleType}","page":"Home","title":"QEDbase.momentum","text":"momentum(psp::AbstractPhaseSpacePoint, dir::ParticleDirection, species::AbstractParticleType)\n\nReturns the momentum of the particle in the given AbstractPhaseSpacePoint with dir and species, if there is only one such particle. If there are multiple or none, an InvalidInputError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.momentum-Tuple{AbstractPhaseSpacePoint, ParticleDirection, Int64}","page":"Home","title":"QEDbase.momentum","text":"momentum(psp::AbstractPhaseSpacePoint, dir::ParticleDirection, n::Int)\n\nReturns the momentum of the nth particle in the given AbstractPhaseSpacePoint which has direction dir. If n is outside the valid range for this phase space point, a BoundsError is thrown.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.momentum-Union{Tuple{N}, Tuple{AbstractPhaseSpacePoint, ParticleDirection, AbstractParticleType, Val{N}}} where N","page":"Home","title":"QEDbase.momentum","text":"momentum(psp::AbstractPhaseSpacePoint, dir::ParticleDirection, species::AbstractParticleType, n::Val{N})\n\nReturns the momentum of the nth particle in the given AbstractPhaseSpacePoint which has direction dir and species species. If n is outside the valid range for this phase space point, a BoundsError is thrown.\n\nnote: Note\nThis function accepts n as a Val{N} type, i.e., a compile-time constant value (for example a literal 1 or 2). This allows this function to add zero overhead, but only if N is actually known at compile time.  If it is not, use the overload of this function that uses n::Int instead. That function is faster than calling this one with Val(n).\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.mul-Union{Tuple{TL}, Tuple{T}, Tuple{T, TL}} where {T<:Union{AbstractDiracMatrix, AbstractDiracVector}, TL<:AbstractLorentzVector}","page":"Home","title":"QEDbase.mul","text":"mul(\n    DM::Union{AbstractDiracMatrix, AbstractDiracVector},\n    L::AbstractLorentzVector\n) -> Any\n\n\nProduct of generic Lorentz vector with a Dirac tensor from the left. Basically, the multiplication is piped to the components from the Lorentz vector.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.mul-Union{Tuple{T}, Tuple{TL}, Tuple{TL, T}} where {TL<:AbstractLorentzVector, T<:Union{AbstractDiracMatrix, AbstractDiracVector}}","page":"Home","title":"QEDbase.mul","text":"mul(\n    L::AbstractLorentzVector,\n    DM::Union{AbstractDiracMatrix, AbstractDiracVector}\n) -> Any\n\n\nProduct of generic Lorentz vector with a Dirac tensor from the right. Basically, the multiplication is piped to the components from the Lorentz vector.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.multiplicity","page":"Home","title":"QEDbase.multiplicity","text":"multiplicity(spin_or_pol)\n\nReturn the number of spins or polarizations respresented by spin_or_pol, e.g. multiplicity(SpinUp()) == 1, but multiplicity(AllSpin()) = 2.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.number_incoming_particles-Tuple{AbstractProcessDefinition}","page":"Home","title":"QEDbase.number_incoming_particles","text":"number_incoming_particles(proc_def::AbstractProcessDefinition)\n\nReturn the number of incoming particles of a given process. \n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.number_outgoing_particles-Tuple{AbstractProcessDefinition}","page":"Home","title":"QEDbase.number_outgoing_particles","text":"number_outgoing_particles(proc_def::AbstractProcessDefinition)\n\nReturn the number of outgoing particles of a given process. \n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.number_particles-Tuple{AbstractProcessDefinition, AbstractParticleStateful}","page":"Home","title":"QEDbase.number_particles","text":"number_particles(proc_def::AbstractProcessDefinition, particle::AbstractParticleStateful)\n\nReturn the number of particles of the given particle's direction and species in the given process definition.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.number_particles-Tuple{AbstractProcessDefinition, Incoming}","page":"Home","title":"QEDbase.number_particles","text":"number_particles(proc_def::AbstractProcessDefinition, dir::ParticleDirection)\n\nConvenience function dispatching to number_incoming_particles or number_outgoing_particles depending on the given direction, returning the number of incoming or outgoing particles, respectively.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.number_particles-Union{Tuple{PT}, Tuple{DIR}, Tuple{AbstractProcessDefinition, DIR, PT}} where {DIR<:ParticleDirection, PT<:AbstractParticleType}","page":"Home","title":"QEDbase.number_particles","text":"number_particles(proc_def::AbstractProcessDefinition, dir::ParticleDirection, species::AbstractParticleType)\n\nReturn the number of particles of the given direction and species in the given process definition.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.out_phase_space_dimension","page":"Home","title":"QEDbase.out_phase_space_dimension","text":"out_phase_space_dimension(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n)\n\nTBW\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.outgoing_particles","page":"Home","title":"QEDbase.outgoing_particles","text":"outgoing_particles(proc_def::AbstractProcessDefinition)\n\nInterface function for scattering processes. Return the tuple of outgoing particles for the given process definition. This function needs to be given to implement the scattering process interface.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.particle_direction","page":"Home","title":"QEDbase.particle_direction","text":"particle_direction(part::AbstractParticleStateful)\n\nInterface function that must return the particle's ParticleDirection.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.particle_species","page":"Home","title":"QEDbase.particle_species","text":"particle_species(part::AbstractParticleStateful)\n\nInterface function that must return the particle's AbstractParticleType, e.g. QEDcore.Electron().\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.particles-Tuple{AbstractProcessDefinition, Incoming}","page":"Home","title":"QEDbase.particles","text":"particles(proc_def::AbstractProcessDefinition, ::ParticleDirection)\n\nConvenience function dispatching to incoming_particles or outgoing_particles depending on the given direction.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.phase_space_definition","page":"Home","title":"QEDbase.phase_space_definition","text":"phase_space_definition(psp::AbstractPhaseSpacePoint)\n\nReturn the phase space point's set phase space definition.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.process","page":"Home","title":"QEDbase.process","text":"process(psp::AbstractPhaseSpacePoint)\n\nReturn the phase space point's set process.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.propagator","page":"Home","title":"QEDbase.propagator","text":"propagator(particle::AbstractParticleType, mom::QEDbase.AbstractFourMomentum, [mass::Real])\n\nReturn the propagator of a particle for a given four-momentum. If mass is passed, the respective propagator for massive particles is used, if not, it is assumed the particle passed in is massless.\n\nnote: Convention\nThere are two types of implementations for propagators given in QEDProcesses:  For a BosonLike particle with four-momentum k and mass m, the propagator is given as D(k) = frac1k^2 - m^2For a FermionLike particle with four-momentum p and mass m, the propagator is given asS(p) = fracgamma^mu p_mu + massp^2 - m^2\n\nwarning: Warning\nThis function does not throw when the given particle is off-shell. If an off-shell particle is passed, the function propagator returns Inf.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.register_LorentzVectorLike-Tuple{Type}","page":"Home","title":"QEDbase.register_LorentzVectorLike","text":"register_LorentzVectorLike(T)\n\n\nFunction to register a custom type as a LorentzVectorLike. \n\nEnsure the passed custom type has implemented at least the function getT, getX, getY, getZ  and enables getter functions of the lorentz vector library for the given type.  If additionally the functions setT!, setX!, setY!, setZ! are implemened for the passed custom type, also the setter functions of the Lorentz vector interface are enabled.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.setCosTheta!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"Home","title":"QEDbase.setCosTheta!","text":"setCosTheta!(lv,value)\n\nSets the cosine of the theta angle of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setCosTheta! is then returned by getCosTheta. Since the cosine of the theta angle is computed on the call of getCosTheta, the setter setCosTheta! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.setE!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"Home","title":"QEDbase.setE!","text":"setE!(lv,value)\n\nSets the energy component of a given LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setE! is then returned by getE.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.setEnergy!","page":"Home","title":"QEDbase.setEnergy!","text":"Function alias for setE!.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.setMinus!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"Home","title":"QEDbase.setMinus!","text":"setMinus!(lv,value)\n\nSets the minus component of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setMinus! is then returned by getMinus. Since the minus component is computed on the call of getMinus, the setter setMinus! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.setMt!","page":"Home","title":"QEDbase.setMt!","text":"Function alias for setTransverseMass!.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.setPerp!","page":"Home","title":"QEDbase.setPerp!","text":"Function alias for setTransverseMomentum!.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.setPhi!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"Home","title":"QEDbase.setPhi!","text":"setPhi!(lv,value)\n\nSets the phi angle of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPhi! is then returned by getPhi. Since the phi angle is computed on the call of getPhi, the setter setPhi! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.setPlus!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"Home","title":"QEDbase.setPlus!","text":"setPlus!(lv,value)\n\nSets the plus component of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPlus! is then returned by getPlus. Since the plus component is computed on the call of getPlus, the setter setPlus! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.setPt!","page":"Home","title":"QEDbase.setPt!","text":"Function alias for setTransverseMomentum!.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.setPx!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"Home","title":"QEDbase.setPx!","text":"setPx!(lv,value)\n\nSets the 1-component of a given LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPx! is then returned by getPx.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.setPy!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"Home","title":"QEDbase.setPy!","text":"setPy!(lv,value)\n\nSets the 2-component of a given LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPy! is then returned by getPy.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.setPz!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"Home","title":"QEDbase.setPz!","text":"setPz!(lv,value)\n\nSets the 3-component of a given LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPz! is then returned by getPz.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.setRapidity!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"Home","title":"QEDbase.setRapidity!","text":"setRapidity!(lv,value)\n\nSets the rapidity of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setRapidity! is then returned by getRapidity. Since the rapidity is computed on the call of setRapidity, the setter setRapidity! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.setRho!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"Home","title":"QEDbase.setRho!","text":"setRho!(lv,value)\n\nSets the magnitude of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setRho! is then returned by getRho. Since the magnitude is computed on the call of getRho, the setter setRho! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.setT!","page":"Home","title":"QEDbase.setT!","text":"setT!(lv,value)\n\nSets the 0-component of a given LorentzVectorLike to the given value.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.setTheta!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"Home","title":"QEDbase.setTheta!","text":"setTheta!(lv,value)\n\nSets the theta angle of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setTheta! is then returned by getTheta. Since the theta angle is computed on the call of getTheta, the setter setTheta! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.setTransverseMass!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"Home","title":"QEDbase.setTransverseMass!","text":"setTransverseMass!(lv,value)\n\nSets the transverse mass of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setTransverseMass! is then returned by getTransverseMass. Since the transverse mass is computed on the call of getTransverseMass, the setter setTransverseMass! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.setTransverseMomentum!-Union{Tuple{VT}, Tuple{T}, Tuple{Type{QEDbase.IsMutableLorentzVectorLike{T}}, T, VT}} where {T, VT}","page":"Home","title":"QEDbase.setTransverseMomentum!","text":"setTransverseMomentum!(lv,value)\n\nSets the transverse momentum of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setTransverseMomentum! is then returned by getTransverseMomentum. Since the transverse momentum is computed on the call of getTransverseMomentum, the setter setTransverseMomentum! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.setX!","page":"Home","title":"QEDbase.setX!","text":"setX!(lv,value)\n\nSets the 1-component of a given LorentzVectorLike to the given value.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.setY!","page":"Home","title":"QEDbase.setY!","text":"setY!(lv,value)\n\nSets the 2-component of a given LorentzVectorLike to the given value.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.setZ!","page":"Home","title":"QEDbase.setZ!","text":"setZ!(lv,value)\n\nSets the 3-component of a given LorentzVectorLike to the given value.\n\n\n\n\n\n","category":"function"},{"location":"#QEDbase.total_cross_section-Tuple{AbstractInPhaseSpacePoint{P, M, D, PS, IN} where {PS<:AbstractParticleStateful, P, M, D, IN<:Tuple{AbstractParticleStateful, Vararg}}}","page":"Home","title":"QEDbase.total_cross_section","text":"total_cross_section(in_psp::AbstractInPhaseSpacePoint)\n\nReturn the total cross section for a given AbstractInPhaseSpacePoint.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.total_probability-Tuple{AbstractInPhaseSpacePoint{P, M, D, PS, IN} where {PS<:AbstractParticleStateful, P, M, D, IN<:Tuple{AbstractParticleStateful, Vararg}}}","page":"Home","title":"QEDbase.total_probability","text":"total_probability(in_psp::AbstractInPhaseSpacePoint)\n\nReturn the total probability of a given AbstractInPhaseSpacePoint.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.unsafe_differential_cross_section-Tuple{AbstractPhaseSpacePoint}","page":"Home","title":"QEDbase.unsafe_differential_cross_section","text":"unsafe_differential_cross_section(phase_space_point::AbstractPhaseSpacePoint)\n\nReturn the differential cross section evaluated on a phase space point without checking if the given phase space is physical.\n\n\n\n\n\n","category":"method"},{"location":"#QEDbase.unsafe_differential_probability-Tuple{AbstractPhaseSpacePoint}","page":"Home","title":"QEDbase.unsafe_differential_probability","text":"unsafe_differential_probability(phase_space_point::AbstractPhaseSpacePoint)\n\nReturn differential probability evaluated on a phase space point without checking if the given phase space(s) are physical.\n\n\n\n\n\n","category":"method"},{"location":"four_momenta/#Four-Momenta","page":"Four Momenta","title":"Four Momenta","text":"","category":"section"},{"location":"four_momenta/","page":"Four Momenta","title":"Four Momenta","text":"Within QEDbase, we model four-momenta with a specialized LorentzVector, where the components are forced to be float:","category":"page"},{"location":"four_momenta/","page":"Four Momenta","title":"Four Momenta","text":"    FourMomentum <:AbstractLorentzVector{::Float64}","category":"page"},{"location":"refs/#References","page":"References","title":"References","text":"","category":"section"},{"location":"refs/","page":"References","title":"References","text":"M. E. Peskin and D. V. Schroeder. An Introduction to quantum field theory (Addison-Wesley, Reading, USA, 1995).\n\n\n\n","category":"page"}]
}
