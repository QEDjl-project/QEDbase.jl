var documenterSearchIndex = {"docs":
[{"location":"library/lorentz_vector/#Lorentz-Vector","page":"Lorentz vectors","title":"Lorentz Vector","text":"","category":"section"},{"location":"library/lorentz_vector/#Interface-registry","page":"Lorentz vectors","title":"Interface registry","text":"","category":"section"},{"location":"library/lorentz_vector/","page":"Lorentz vectors","title":"Lorentz vectors","text":"register_LorentzVectorLike","category":"page"},{"location":"library/lorentz_vector/#QEDbase.register_LorentzVectorLike","page":"Lorentz vectors","title":"QEDbase.register_LorentzVectorLike","text":"register_LorentzVectorLike(T)\n\n\nFunction to register a custom type as a LorentzVectorLike.\n\nEnsure the passed custom type has implemented at least the function getT, getX, getY, getZ and enables getter functions of the lorentz vector library for the given type. If additionally the functions setT!, setX!, setY!, setZ! are implemened for the passed custom type, also the setter functions of the Lorentz vector interface are enabled.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#Built-in-Lorentz-vector-types","page":"Lorentz vectors","title":"Built-in Lorentz vector types","text":"","category":"section"},{"location":"library/lorentz_vector/","page":"Lorentz vectors","title":"Lorentz vectors","text":"AbstractLorentzVector\nAbstractFourMomentum","category":"page"},{"location":"library/lorentz_vector/#QEDbase.AbstractLorentzVector","page":"Lorentz vectors","title":"QEDbase.AbstractLorentzVector","text":"abstract type AbstractLorentzVector{T} <: StaticArraysCore.FieldVector{4, T}\n\nAbstract type to model generic Lorentz vectors, i.e. elements of a minkowski-like space, where the component space is arbitray.\n\n\n\n\n\n","category":"type"},{"location":"library/lorentz_vector/#QEDbase.AbstractFourMomentum","page":"Lorentz vectors","title":"QEDbase.AbstractFourMomentum","text":"AbstractFourMomentum\n\nAbstract base type for four-momentas, representing one energy and three spacial components.\n\nAlso see: QEDcore.SFourMomentum, QEDcore.MFourMomentum\n\n\n\n\n\n","category":"type"},{"location":"library/lorentz_vector/#Accessor-functions","page":"Lorentz vectors","title":"Accessor functions","text":"","category":"section"},{"location":"library/lorentz_vector/","page":"Lorentz vectors","title":"Lorentz vectors","text":"minkowski_dot\nmdot\ngetT\ngetX\ngetY\ngetZ\ngetMagnitude2\ngetMag2\ngetMagnitude\ngetMag\n\ngetInvariantMass2\ngetMass2\ngetInvariantMass\ngetMass\ngetE\ngetEnergy\ngetPx\ngetPy\ngetPz\ngetBeta\ngetGamma\n\ngetTransverseMomentum2\ngetPt2\ngetPerp2\ngetTransverseMomentum\ngetPt\ngetPerp\ngetTransverseMass2\ngetMt2\ngetTransverseMass\ngetMt\ngetRapidity\n\ngetRho2\ngetRho\ngetTheta\ngetCosTheta\ngetPhi\ngetCosPhi\ngetSinPhi\ngetPlus\ngetMinus","category":"page"},{"location":"library/lorentz_vector/#QEDbase.minkowski_dot","page":"Lorentz vectors","title":"QEDbase.minkowski_dot","text":"minkowski_dot(v1,v2)\n\nReturn the Minkowski dot product of two LorentzVectorLike.\n\nexample: Example\nIf (t1,x1,y1,z1) and (t2,x2,y2,z2) are two LorentzVectorLike, this is equivalent tot1*t2 - (x1*x2 + y1*y2 + z1*z2)\n\nnote: Note\nWe use the mostly minus metric.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.mdot","page":"Lorentz vectors","title":"QEDbase.mdot","text":"Function alias for minkowski_dot.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getT","page":"Lorentz vectors","title":"QEDbase.getT","text":"getT(lv)\n\nReturn the 0-component of a given LorentzVectorLike.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to t.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getX","page":"Lorentz vectors","title":"QEDbase.getX","text":"getX(lv)\n\nReturn the 1-component of a given LorentzVectorLike.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to x.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getY","page":"Lorentz vectors","title":"QEDbase.getY","text":"getY(lv)\n\nReturn the 2-component of a given LorentzVectorLike.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to y.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getZ","page":"Lorentz vectors","title":"QEDbase.getZ","text":"getZ(lv)\n\nReturn the 3-component of a given LorentzVectorLike.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to z.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getMagnitude2","page":"Lorentz vectors","title":"QEDbase.getMagnitude2","text":"getMagnitude2(lv)\n\nReturn the square of the magnitude of a given LorentzVectorLike, i.e. the sum of the squared spatial components.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to x^2+ y^2 + z^2.\n\nwarning: Warning\nThis function differs from a similar function for the TLorentzVector used in the famous ROOT library.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getMag2","page":"Lorentz vectors","title":"QEDbase.getMag2","text":"Functiom alias for getMagnitude2.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getMagnitude","page":"Lorentz vectors","title":"QEDbase.getMagnitude","text":"getMagnitude(lv)\n\nReturn the magnitude of a given LorentzVectorLike, i.e. the euklidian norm spatial components.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to sqrt(x^2 + y^2 + z^2).\n\nwarning: Warning\nThis function differs from a similar function for the TLorentzVector used in the famous ROOT library.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getMag","page":"Lorentz vectors","title":"QEDbase.getMag","text":"Functiom alias for getMagnitude.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getInvariantMass2","page":"Lorentz vectors","title":"QEDbase.getInvariantMass2","text":"getInvariantMass2(lv)\n\nReturn the squared invariant mass of a given LorentzVectorLike, i.e. the minkowski dot with itself.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to t^2 - (x^2 + y^2 + z^2).\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getMass2","page":"Lorentz vectors","title":"QEDbase.getMass2","text":"Function alias for getInvariantMass2\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getInvariantMass","page":"Lorentz vectors","title":"QEDbase.getInvariantMass","text":"getInvariantMass(lv)\n\nReturn the the invariant mass of a given LorentzVectorLike, i.e. the square root of the minkowski dot with itself.\n\nexample: Example\nIf (t,x,y,z) is a LorentzVectorLike, this is equivalent to sqrt(t^2 - (x^2 + y^2 + z^2)).\n\nnote: Note\nIf the squared invariant mass m2 is negative, -sqrt(-m2) is returned.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getMass","page":"Lorentz vectors","title":"QEDbase.getMass","text":"Function alias for getInvariantMass.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getE","page":"Lorentz vectors","title":"QEDbase.getE","text":"getE(lv)\n\nReturn the energy component of a given LorentzVectorLike, i.e. its 0-component.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to E.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getEnergy","page":"Lorentz vectors","title":"QEDbase.getEnergy","text":"Function alias for getE.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getPx","page":"Lorentz vectors","title":"QEDbase.getPx","text":"getPx(lv)\n\nReturn the p_x component of a given LorentzVectorLike, i.e. its 1-component.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to px.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getPy","page":"Lorentz vectors","title":"QEDbase.getPy","text":"getPy(lv)\n\nReturn the p_y component of a given LorentzVectorLike, i.e. its 2-component.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to py.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getPz","page":"Lorentz vectors","title":"QEDbase.getPz","text":"getPz(lv)\n\nReturn the p_z component of a given LorentzVectorLike, i.e. its 3-component.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to pz.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getBeta","page":"Lorentz vectors","title":"QEDbase.getBeta","text":"getBeta(lv)\n\nReturn magnitude of the beta vector for a given LorentzVectorLike, i.e. the magnitude of the LorentzVectorLike divided by its 0-component.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to sqrt(px^2 + py^2 + pz^2)/E.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getGamma","page":"Lorentz vectors","title":"QEDbase.getGamma","text":"getGamma(lv)\n\nReturn the relativistic gamma factor for a given LorentzVectorLike, i.e. the inverse square root of one minus the beta vector squared.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike with beta vector β, this is equivalent to 1/sqrt(1- β^2).\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getTransverseMomentum2","page":"Lorentz vectors","title":"QEDbase.getTransverseMomentum2","text":"getTransverseMomentum2(lv)\n\nReturn the squared transverse momentum for a given LorentzVectorLike, i.e. the sum of its squared 1- and 2-component.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to px^2 + py^2.\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getPt2","page":"Lorentz vectors","title":"QEDbase.getPt2","text":"Function alias for getTransverseMomentum2.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getPerp2","page":"Lorentz vectors","title":"QEDbase.getPerp2","text":"Function alias for getTransverseMomentum2.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getTransverseMomentum","page":"Lorentz vectors","title":"QEDbase.getTransverseMomentum","text":"getTransverseMomentum(lv)\n\nReturn the transverse momentum for a given LorentzVectorLike, i.e. the magnitude of its transverse components.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to sqrt(px^2 + py^2).\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getPt","page":"Lorentz vectors","title":"QEDbase.getPt","text":"Function alias for getTransverseMomentum.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getPerp","page":"Lorentz vectors","title":"QEDbase.getPerp","text":"Function alias for getTransverseMomentum.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getTransverseMass2","page":"Lorentz vectors","title":"QEDbase.getTransverseMass2","text":"getTransverseMass2(lv)\n\nReturn the squared transverse mass for a given LorentzVectorLike, i.e. the difference of its squared 0- and 3-component.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to E^2 - pz^2.\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getMt2","page":"Lorentz vectors","title":"QEDbase.getMt2","text":"Function alias for getTransverseMass2\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getTransverseMass","page":"Lorentz vectors","title":"QEDbase.getTransverseMass","text":"getTransverseMass(lv)\n\nReturn the transverse momentum for a given LorentzVectorLike, i.e. the square root of its squared transverse mass.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to sqrt(E^2 - pz^2).\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis.\n\nnote: Note\nIf the squared transverse mass mT2 is negative, -sqrt(-mT2) is returned.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getMt","page":"Lorentz vectors","title":"QEDbase.getMt","text":"Function alias for getTransverseMass\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getRapidity","page":"Lorentz vectors","title":"QEDbase.getRapidity","text":"getRapidity(lv)\n\nReturn the rapidity for a given LorentzVectorLike.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to 0.5*log((E+pz)/(E-pz)).\n\nnote: Note\nThe transverse components are defined w.r.t. to the 3-axis.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getRho2","page":"Lorentz vectors","title":"QEDbase.getRho2","text":"Function alias for getMagnitude2\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getRho","page":"Lorentz vectors","title":"QEDbase.getRho","text":"Function alias for getMagnitude\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getTheta","page":"Lorentz vectors","title":"QEDbase.getTheta","text":"getTheta(lv)\n\nReturn the theta angle for a given LorentzVectorLike, i.e. the polar angle of its spatial components in spherical coordinates.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike with magnitude rho, this is equivalent to arccos(pz/rho), which is also equivalent to arctan(sqrt(px^2+py^2)/pz).\n\nnote: Note\nThe spherical coordinates are defined w.r.t. to the 3-axis.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getCosTheta","page":"Lorentz vectors","title":"QEDbase.getCosTheta","text":"getCosTheta(lv)\n\nReturn the cosine of the theta angle for a given LorentzVectorLike.\n\nnote: Note\nThis is an equivalent but faster version of cos(getTheta(lv)); see getTheta.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getPhi","page":"Lorentz vectors","title":"QEDbase.getPhi","text":"getPhi(lv)\n\nReturn the phi angle for a given LorentzVectorLike, i.e. the azimuthal angle of its spatial components in spherical coordinates.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to atan(py,px).\n\nnote: Note\nThe spherical coordinates are defined w.r.t. to the 3-axis.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getCosPhi","page":"Lorentz vectors","title":"QEDbase.getCosPhi","text":"getCosPhi(lv)\n\nReturn the cosine of the phi angle for a given LorentzVectorLike.\n\nnote: Note\nThis is an equivalent but faster version of cos(getPhi(lv)); see getPhi.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getSinPhi","page":"Lorentz vectors","title":"QEDbase.getSinPhi","text":"getSinPhi(lv)\n\nReturn the sine of the phi angle for a given LorentzVectorLike.\n\nnote: Note\nThis is an equivalent but faster version of sin(getPhi(lv)); see getPhi.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getPlus","page":"Lorentz vectors","title":"QEDbase.getPlus","text":"getPlus(lv)\n\nReturn the plus component for a given LorentzVectorLike in light-cone coordinates.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to (E+pz)/2.\n\nnote: Note\nThe light-cone coordinates are defined w.r.t. to the 3-axis.\n\nwarning: Warning\nThe definition `p^+ := (E + p_z)/2 differs from the usual definition of light-cone coordinates in general relativity.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.getMinus","page":"Lorentz vectors","title":"QEDbase.getMinus","text":"getMinus(lv)\n\nReturn the minus component for a given LorentzVectorLike in light-cone coordinates.\n\nexample: Example\nIf (E,px,py,pz) is a LorentzVectorLike, this is equivalent to (E-pz)/2.\n\nnote: Note\nThe light-cone coordinates are defined w.r.t. to the 3-axis.\n\nwarning: Warning\nThe definition `p^- := (E - p_z)/2 differs from the usual definition of light-cone coordinates in general relativity.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#Setter-functions","page":"Lorentz vectors","title":"Setter functions","text":"","category":"section"},{"location":"library/lorentz_vector/","page":"Lorentz vectors","title":"Lorentz vectors","text":"setE!\nsetEnergy!\nsetPx!\nsetPy!\nsetPz!\nsetTheta!\nsetCosTheta!\nsetRho!\nsetPhi!\nsetPlus!\nsetMinus!\n\nsetTransverseMomentum!\nsetPerp!\nsetPt!\nsetTransverseMass!\nsetMt!\nsetRapidity!","category":"page"},{"location":"library/lorentz_vector/#QEDbase.setE!","page":"Lorentz vectors","title":"QEDbase.setE!","text":"setE!(lv,value)\n\nSets the energy component of a given LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setE! is then returned by getE.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setEnergy!","page":"Lorentz vectors","title":"QEDbase.setEnergy!","text":"Function alias for setE!.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setPx!","page":"Lorentz vectors","title":"QEDbase.setPx!","text":"setPx!(lv,value)\n\nSets the 1-component of a given LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPx! is then returned by getPx.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setPy!","page":"Lorentz vectors","title":"QEDbase.setPy!","text":"setPy!(lv,value)\n\nSets the 2-component of a given LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPy! is then returned by getPy.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setPz!","page":"Lorentz vectors","title":"QEDbase.setPz!","text":"setPz!(lv,value)\n\nSets the 3-component of a given LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPz! is then returned by getPz.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setTheta!","page":"Lorentz vectors","title":"QEDbase.setTheta!","text":"setTheta!(lv,value)\n\nSets the theta angle of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setTheta! is then returned by getTheta. Since the theta angle is computed on the call of getTheta, the setter setTheta! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setCosTheta!","page":"Lorentz vectors","title":"QEDbase.setCosTheta!","text":"setCosTheta!(lv,value)\n\nSets the cosine of the theta angle of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setCosTheta! is then returned by getCosTheta. Since the cosine of the theta angle is computed on the call of getCosTheta, the setter setCosTheta! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setRho!","page":"Lorentz vectors","title":"QEDbase.setRho!","text":"setRho!(lv,value)\n\nSets the magnitude of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setRho! is then returned by getRho. Since the magnitude is computed on the call of getRho, the setter setRho! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setPhi!","page":"Lorentz vectors","title":"QEDbase.setPhi!","text":"setPhi!(lv,value)\n\nSets the phi angle of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPhi! is then returned by getPhi. Since the phi angle is computed on the call of getPhi, the setter setPhi! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setPlus!","page":"Lorentz vectors","title":"QEDbase.setPlus!","text":"setPlus!(lv,value)\n\nSets the plus component of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setPlus! is then returned by getPlus. Since the plus component is computed on the call of getPlus, the setter setPlus! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setMinus!","page":"Lorentz vectors","title":"QEDbase.setMinus!","text":"setMinus!(lv,value)\n\nSets the minus component of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setMinus! is then returned by getMinus. Since the minus component is computed on the call of getMinus, the setter setMinus! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setTransverseMomentum!","page":"Lorentz vectors","title":"QEDbase.setTransverseMomentum!","text":"setTransverseMomentum!(lv,value)\n\nSets the transverse momentum of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setTransverseMomentum! is then returned by getTransverseMomentum. Since the transverse momentum is computed on the call of getTransverseMomentum, the setter setTransverseMomentum! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setPerp!","page":"Lorentz vectors","title":"QEDbase.setPerp!","text":"Function alias for setTransverseMomentum!.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setPt!","page":"Lorentz vectors","title":"QEDbase.setPt!","text":"Function alias for setTransverseMomentum!.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setTransverseMass!","page":"Lorentz vectors","title":"QEDbase.setTransverseMass!","text":"setTransverseMass!(lv,value)\n\nSets the transverse mass of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setTransverseMass! is then returned by getTransverseMass. Since the transverse mass is computed on the call of getTransverseMass, the setter setTransverseMass! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setMt!","page":"Lorentz vectors","title":"QEDbase.setMt!","text":"Function alias for setTransverseMass!.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.setRapidity!","page":"Lorentz vectors","title":"QEDbase.setRapidity!","text":"setRapidity!(lv,value)\n\nSets the rapidity of a LorentzVectorLike to a given value.\n\nnote: Note\nThe value set with setRapidity! is then returned by getRapidity. Since the rapidity is computed on the call of setRapidity, the setter setRapidity! changes several components of the given LorentzVectorLike.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#Utilities","page":"Lorentz vectors","title":"Utilities","text":"","category":"section"},{"location":"library/lorentz_vector/","page":"Lorentz vectors","title":"Lorentz vectors","text":"isonshell\nassert_onshell\nAbstractCoordinateTransformation","category":"page"},{"location":"library/lorentz_vector/#QEDbase.isonshell","page":"Lorentz vectors","title":"QEDbase.isonshell","text":"isonshell(mom, mass)\n\n\nOn-shell check of a given four-momentum mom w.r.t. a given mass mass.\n\nnote: Precision\nFor AbstactFourMomentum, the element type is fixed to Float64, limiting the precision of comparisons between elements. The current implementation has been tested within the boundaries for energy scales E with 1e-9 <= E <= 1e5. In those bounds, the mass error, which is correctly detected as off-shell, is 1e-4 times the mean value of the components, but has at most the value 0.01, e.g. at the high energy end. The energy scales correspond to 0.5 meV for the lower bound and 50 GeV for the upper bound.\n\ntodo: FourMomenta with real entries\nif AbstractFourMomentum is updated to elementtypes T<:Real, the AbstractLorentzVector should be updated with the AbstractFourMomentum.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.assert_onshell","page":"Lorentz vectors","title":"QEDbase.assert_onshell","text":"assert_onshell(mom, mass)\n\n\nAssertion if a FourMomentum mom is on-shell w.r.t a given mass mass.\n\nnote: See also\nThe precision of this functions is explained in isonshell.\n\n\n\n\n\n","category":"function"},{"location":"library/lorentz_vector/#QEDbase.AbstractCoordinateTransformation","page":"Lorentz vectors","title":"QEDbase.AbstractCoordinateTransformation","text":"AbstractCoordinateTransformation\n\nAbstract base type for coordinate transformations supposed to be acting on four-momenta. Every subtype of trafo::AbstractCoordinateTransformation should implement the following interface functions:\n\nQEDbase._transform(trafo,p): transforms p\nBase.inv(trafo): returns the inverted transform\n\nExample\n\nImplementing the interface by defining the interface functions:\n\njulia> using QEDbase\n\njulia> struct TestTrafo{T} <: AbstractCoordinateTransformation\n           a::T\n       end\n\njulia> QEDbase._transform(trafo::TestTrafo,p) = trafo.a*p\n\njulia> Base.inv(trafo::TestTrafo) = TestTrafo(inv(trafo.a))\n\n\nThe TestTrafo can then be used to transform four-momenta:\n\njulia> trafo = TestTrafo(2.0)\nTestTrafo{Float64}(2.0)\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> trafo(p) # multiply every component with 2.0\n4-element SFourMomentum with indices SOneTo(4):\n 8.0\n 6.0\n 4.0\n 2.0\n\njulia> inv(trafo)(p) # divide every component by 2.0\n4-element SFourMomentum with indices SOneTo(4):\n 2.0\n 1.5\n 1.0\n 0.5\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space_layout/#Phase-Space-Layout","page":"Phase space layout","title":"Phase Space Layout","text":"","category":"section"},{"location":"library/phase_space_layout/","page":"Phase space layout","title":"Phase space layout","text":"CurrentModule = QEDbase","category":"page"},{"location":"library/phase_space_layout/#Phase-Space-Layout-Interface","page":"Phase space layout","title":"Phase Space Layout Interface","text":"","category":"section"},{"location":"library/phase_space_layout/","page":"Phase space layout","title":"Phase space layout","text":"AbstractPhaseSpaceLayout\nAbstractInPhaseSpaceLayout\nAbstractOutPhaseSpaceLayout\n_build_momenta\nphase_space_dimension\nin_phase_space_layout","category":"page"},{"location":"library/phase_space_layout/#QEDbase.AbstractPhaseSpaceLayout","page":"Phase space layout","title":"QEDbase.AbstractPhaseSpaceLayout","text":"AbstractPhaseSpaceLayout\n\nThe AbstractPhaseSpaceLayout is an abstract type that represents the general concept of a phase space layout in a scattering process.\n\nInterface Functions to Implement:\n\nphase_space_dimension(proc, model, layout::AbstractPhaseSpaceLayout): Defines the number   of independent phase space coordinates needed to build the momenta.\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space_layout/#QEDbase.AbstractInPhaseSpaceLayout","page":"Phase space layout","title":"QEDbase.AbstractInPhaseSpaceLayout","text":"AbstractInPhaseSpaceLayout <: AbstractPhaseSpaceLayout\n\nThe AbstractInPhaseSpaceLayout represents the phase space layout for the incoming particles in a scattering process. It defines the way in which the momenta of incoming particles are constructed from phase space coordinates.\n\nInterface Functions to Implement:\n\nphase_space_dimension(proc, model, layout::AbstractInPhaseSpaceLayout): Defines the number   of independent phase space coordinates for the incoming particles.\n_build_momenta(proc, model, in_psl::AbstractInPhaseSpaceLayout, in_coords::Tuple): Constructs   the momenta for the incoming particles using the phase space coordinates.\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space_layout/#QEDbase.AbstractOutPhaseSpaceLayout","page":"Phase space layout","title":"QEDbase.AbstractOutPhaseSpaceLayout","text":"AbstractOutPhaseSpaceLayout{IN_PSL<:AbstractInPhaseSpaceLayout} <: AbstractPhaseSpaceLayout\n\nThe AbstractOutPhaseSpaceLayout represents the phase space layout for the outgoing particles in a scattering process. It typically depends on the phase space layout of the incoming particles and specifies how the momenta of the outgoing particles are constructed from the respective coordinates.\n\nThe generic parameter IN_PSL links the outgoing phase space layout to the incoming layout, allowing consistency between the two configurations in the process.\n\nInterface Functions to Implement:\n\nphase_space_dimension(proc, model, layout::AbstractOutPhaseSpaceLayout): Defines the   number of independent phase space coordinates for the outgoing particles.\nin_phase_space_layout(out_psl::AbstractOutPhaseSpaceLayout): Provides the associated   incoming phase space layout to ensure consistency between incoming and outgoing configurations.\n_build_momenta(proc, model, Ptot::AbstractFourMomentum, out_psl::AbstractOutPhaseSpaceLayout, out_coords::Tuple):   Constructs the momenta for the outgoing particles, ensuring they comply with energy and momentum conservation based on the total incoming four-momentum.\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space_layout/#QEDbase._build_momenta","page":"Phase space layout","title":"QEDbase._build_momenta","text":"_build_momenta(proc, model, in_psl::AbstractInPhaseSpaceLayout, in_coords::Tuple)\n_build_momenta(proc, model, Ptot::AbstractFourMomentum, out_psl::AbstractOutPhaseSpaceLayout, out_coords::Tuple)\n\nThese functions need to be implemented as part of the phase space layout interface for both incoming and outgoing particle momenta construction. They serve as internal, low-level interfaces for constructing the four-momenta of particles during a scattering process, and are typically wrapped by the user-facing build_momenta function.\n\nIncoming Phase Space Layout\n\nThe first function, _build_momenta(proc, model, in_psl, in_coords), constructs the four-momenta for the incoming particles based on the specified phase space coordinates (in_coords).\n\nArguments:\nproc: The scattering process definition, subtype of AbstractProcessDefinition.\nmodel: The physics model, subtype of AbstractModelDefinition.\nin_psl: The incoming phase space layout, subtype of AbstractInPhaseSpaceLayout,   that defines how to map the coordinates to momenta.\nin_coords: A tuple of phase space coordinates that parametrize the momenta of the   incoming particles.\nReturns:\nA collection of four-momenta representing the incoming particles. For performance reasons,   it is recommended to return a Tuple of four-momenta.\n\nOutgoing Phase Space Layout\n\nThe second function, _build_momenta(proc, model, Ptot, out_psl, out_coords), constructs the four-momenta for the outgoing particles. It uses the incoming four-momenta (in_moms) from the incoming state and applies the phase space coordinates (out_coords) to compute the outgoing momenta, ensuring they adhere to energy and momentum conservation laws.\n\nArguments:\nproc: The scattering process definition, subtype of AbstractProcessDefinition.\nmodel: The physics model, subtype of AbstractModelDefinition.\nin_moms: The incoming four-momenta, which is used to compute the momenta of the   outgoing particles.\nout_psl: The outgoing phase space layout, subtype of AbstractOutPhaseSpaceLayout,   that maps the coordinates to momenta.\nout_coords: A tuple of phase space coordinates that parametrize the outgoing particle   momenta.\nReturns:\nA collection of four-momenta representing the outgoing particles. For performance reasons,   it is recommended to return a Tuple of four-momenta.\n\nNotes\n\nBoth versions of _build_momenta handle the construction of particle momenta during different phases of the scattering process:\n\nThe incoming version constructs momenta based on phase space coordinates alone.\nThe outgoing version constructs momenta based on both phase space coordinates and   the total four-momentum, ensuring conservation laws are respected.\n\n\n\n\n\n","category":"function"},{"location":"library/phase_space_layout/#QEDbase.phase_space_dimension","page":"Phase space layout","title":"QEDbase.phase_space_dimension","text":"phase_space_dimension(proc, model, layout::AbstractPhaseSpaceLayout)::Int\n\nThis function needs to be implemented for the phase-space layout interface. Return the dimensionality of the phase space, i.e., the number of coordinates, for a given process and model within the specified layout.\n\nThe phase space dimension is a crucial quantity that determines how many independent coordinates are required to describe the system of particles in the scattering process. It depends on the number of particles involved and the specific interaction model in use.\n\nArguments\n\nproc: The scattering process definition, a subtype of AbstractProcessDefinition.\nmodel: The physics model, a subtype of AbstractModelDefinition.\nlayout: A specific phase space layout, either AbstractInPhaseSpaceLayout or   AbstractOutPhaseSpaceLayout.\n\nReturns\n\nThe integer representing the number of independent phase space coordinates.\n\nnote: Note\nThis function should return a compile-time constant, i.e., a number that can be inferred from the type information of the function call alone. If this is not the case, build_momenta and other derived functions may become very slow.\n\n\n\n\n\n","category":"function"},{"location":"library/phase_space_layout/#QEDbase.in_phase_space_layout","page":"Phase space layout","title":"QEDbase.in_phase_space_layout","text":"in_phase_space_layout(out_psl::AbstractOutPhaseSpaceLayout)::AbstractInPhaseSpaceLayout\n\nThis function needs to be implemented for the AbstractOutPhaseSpaceLayout interface. Given an outgoing phase space layout (out_psl), this function returns the associated incoming phase space layout.\n\nThis is useful for ensuring consistency between the incoming and outgoing particle momenta when calculating or sampling phase space points in scattering processes.\n\nArguments\n\nout_psl: The outgoing phase space layout, a subtype of AbstractOutPhaseSpaceLayout.\n\nReturns\n\nThe associated incoming phase space layout, a subtype of AbstractInPhaseSpaceLayout.\n\n\n\n\n\n","category":"function"},{"location":"library/phase_space_layout/#Building-Momenta","page":"Phase space layout","title":"Building Momenta","text":"","category":"section"},{"location":"library/phase_space_layout/","page":"Phase space layout","title":"Phase space layout","text":"build_momenta","category":"page"},{"location":"library/phase_space_layout/#QEDbase.build_momenta","page":"Phase space layout","title":"QEDbase.build_momenta","text":"build_momenta(proc, model, in_psl::AbstractInPhaseSpaceLayout, in_coords::Tuple)\n\nConstruct the momenta of the incoming particles using the provided phase space coordinates.\n\nThis is the user-facing function that calls _build_momenta internally and validates the number of coordinates against the phase space dimensionality.\n\nArguments\n\nproc: The scattering process definition, subtype of AbstractProcessDefinition.\nmodel: The physics model, subtype of AbstractModelDefinition.\nin_psl: The incoming phase space layout, subtype of AbstractInPhaseSpaceLayout.\nin_coords: A tuple of phase space coordinates that parametrize the incoming particle momenta.\n\nReturns\n\nA collection of four-momenta representing the incoming particles. Because of performance   reasons, it is recommended to return a Tuple of four-momenta.\n\n\n\n\n\nbuild_momenta(proc::AbstractProcessDefinition, model::AbstractModelDefinition, in_psl::AbstractInPhaseSpaceLayout, in_coords::Real)\n\nA scalar version of build_momenta for incoming phase space layouts (in_psl), where the phase space coordinates are provided as a single scalar instead of a tuple.\n\nArguments:\n\nproc: The scattering process definition, subtype of AbstractProcessDefinition.\nmodel: The physics model, subtype of AbstractModelDefinition.\nin_psl: The incoming phase space layout, subtype of AbstractInPhaseSpaceLayout.\nin_coords::Real: A single scalar representing the phase space coordinate for the   incoming particles.\n\nReturns:\n\nA collection of four-momenta representing the incoming particles. For performance   reasons, it is recommended to return a Tuple of four-momenta.\n\nNotes:\n\nThis function is a convenience wrapper around build_momenta, automatically converting the scalar in_coords into a 1-tuple. It is useful when the incoming phase space only requires a single coordinate to define the particle momenta.\n\n\n\n\n\nbuild_momenta(proc, model, Ptot::AbstractFourMomentum, out_psl::AbstractOutPhaseSpaceLayout, out_coords::Tuple)\n\nConstruct the momenta of the outgoing particles using the provided phase space coordinates (out_coords) and total incoming momentum (Ptot).\n\nThis function ensures that the outgoing momenta satisfy energy and momentum conservation, consistent with the physics model in use.\n\nArguments\n\nproc: The scattering process definition, subtype of AbstractProcessDefinition.\nmodel: The physics model, subtype of AbstractModelDefinition.\nin_moms: The incoming four-momenta, used to compute the outgoing momenta.\nout_psl: The outgoing phase space layout, subtype of `AbstractOutPhaseSpaceLayout.\nout_coords: A tuple of phase space coordinates that parametrize the outgoing particle momenta.\n\nReturns\n\nA collection of four-momenta representing the incoming particles. Because of performance   reasons, it is recommened to return a Tuple of four-momenta.\n\n\n\n\n\n","category":"function"},{"location":"library/particles/#Particle-Interface","page":"Particles","title":"Particle Interface","text":"","category":"section"},{"location":"library/particles/#Mandatory-Interface","page":"Particles","title":"Mandatory Interface","text":"","category":"section"},{"location":"library/particles/","page":"Particles","title":"Particles","text":"AbstractParticle\nAbstractParticleType\nmass\ncharge\nbase_state\npropagator","category":"page"},{"location":"library/particles/#QEDbase.AbstractParticle","page":"Particles","title":"QEDbase.AbstractParticle","text":"Abstract base type for every type which might be considered a particle in the context of QuantumElectrodynamics.jl. For every (concrete) subtype of AbstractParticle, there are two kinds of interface functions implemented: static functions and property functions. The static functions provide information on what kind of particle it is (defaults are written in square brackets)\n\n    is_fermion(::AbstractParticle)::Bool [= false]\n    is_boson(::AbstractParticle)::Bool [= false]\n    is_particle(::AbstractParticle)::Bool [= true]\n    is_anti_particle(::AbstractParticle)::Bool [= false]\n\nIf the output of those functions differ from the defaults for a subtype of AbstractParticle, these functions need to be overwritten. The second type of functions define a hard interface for AbstractParticle:\n\n    mass(::AbstractParticle)::Real\n    charge(::AbstractParticle)::Real\n\nThese functions must be implemented in order to have the subtype of AbstractParticle work with the functionalities of QEDprocesses.jl.\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDbase.AbstractParticleType","page":"Particles","title":"QEDbase.AbstractParticleType","text":"AbstractParticleType <: AbstractParticle\n\nThis is the abstract base type for every species of particles. All functionalities defined on subtypes of AbstractParticleType should be static, i.e. known at compile time. For adding runtime information, e.g. four-momenta or particle states, to a particle, consider implementing a concrete subtype of AbstractParticle instead, which may have a type parameter P<:AbstractParticleType.\n\nConcrete built-in subtypes of AbstractParticleType are available in QEDcore.jl and should always be singletons..\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDbase.mass","page":"Particles","title":"QEDbase.mass","text":"mass(particle::AbstractParticle)::Real\n\nInterface function for particles. Return the rest mass of a particle (in units of the electron mass).\n\nThis needs to be implemented for each concrete subtype of AbstractParticle.\n\n\n\n\n\n","category":"function"},{"location":"library/particles/#QEDbase.charge","page":"Particles","title":"QEDbase.charge","text":"charge(::AbstractParticle)::Real\n\nInterface function for particles. Return the electric charge of a particle (in units of the elementary electric charge).\n\nThis needs to be implemented for each concrete subtype of AbstractParticle.\n\n\n\n\n\n","category":"function"},{"location":"library/particles/#QEDbase.base_state","page":"Particles","title":"QEDbase.base_state","text":"    base_state(\n        particle::AbstractParticleType,\n        direction::ParticleDirection,\n        momentum::QEDbase.AbstractFourMomentum,\n        [spin_or_pol::AbstractSpinOrPolarization]\n    )\n\nReturn the base state of a directed on-shell particle with a given four-momentum. For internal usage only.\n\nInput\n\nparticle – the type of the particle, i.e., an instance of an AbstractParticleType, e.g. QEDcore.Electron, QEDcore.Positron, or QEDcore.Photon.\ndirection – the direction of the particle, i.e. Incoming or Outgoing.\nmomentum – the four-momentum of the particle\n[spin_or_pol] – if given, the spin or polarization of the particle, e.g. SpinUp/SpinDown or PolarizationX/PolarizationY.\n\nOutput\n\nThe output type of base_state depends on wether the spin or polarization of the particle passed in is specified or not.\n\nIf spin_or_pol is passed, the output of base_state is\n\nbase_state(::Fermion,     ::Incoming, mom, spin_or_pol) # -> BiSpinor\nbase_state(::AntiFermion, ::Incoming, mom, spin_or_pol) # -> AdjointBiSpinor\nbase_state(::Fermion,     ::Outgoing, mom, spin_or_pol) # -> AdjointBiSpinor\nbase_state(::AntiFermion, ::Outgoing, mom, spin_or_pol) # -> BiSpinor\nbase_state(::Photon,      ::Incoming, mom, spin_or_pol) # -> SLorentzVector{ComplexF64}\nbase_state(::Photon,      ::Outgoing, mom, spin_or_pol) # -> SLorentzVector{ComplexF64}\n\nIf spin_or_pol is of type AllPolarization or AllSpin, the output is an SVector with both spin/polarization alignments:\n\nbase_state(::Fermion,     ::Incoming, mom) # -> SVector{2,BiSpinor}\nbase_state(::AntiFermion, ::Incoming, mom) # -> SVector{2,AdjointBiSpinor}\nbase_state(::Fermion,     ::Outgoing, mom) # -> SVector{2,AdjointBiSpinor}\nbase_state(::AntiFermion, ::Outgoing, mom) # -> SVector{2,BiSpinor}\nbase_state(::Photon,      ::Incoming, mom) # -> SVector{2,SLorentzVector{ComplexF64}}\nbase_state(::Photon,      ::Outgoing, mom) # -> SVector{2,SLorentzVector{ComplexF64}}\n\nExample\n\nusing QEDbase, QEDcore\n\nmass = 1.0                              # set electron mass to 1.0\npx,py,pz = rand(3)                      # generate random spatial components\nE = sqrt(px^2 + py^2 + pz^2 + mass^2)   # compute energy, i.e. the electron is on-shell\nmom = SFourMomentum(E, px, py, pz)      # initialize the four-momentum of the electron\n\n# compute the state of an incoming electron with spin = SpinUp\n# note: base_state is not exported!\nelectron_state = base_state(QEDcore.Electron(), Incoming(), mom, SpinUp())\n\njulia> using QEDbase; using QEDcore;\n\njulia> mass = 1.0; px,py,pz = (0.1, 0.2, 0.3); E = sqrt(px^2 + py^2 + pz^2 + mass^2); mom = SFourMomentum(E, px, py, pz)\n4-element SFourMomentum with indices SOneTo(4):\n 1.0677078252031311\n 0.1\n 0.2\n 0.3\n\njulia> electron_state = base_state(Electron(), Incoming(), mom, SpinUp())\n4-element BiSpinor with indices SOneTo(4):\n   1.4379526505428235 + 0.0im\n                  0.0 + 0.0im\n -0.20862995724285552 + 0.0im\n -0.06954331908095185 - 0.1390866381619037im\n\njulia> electron_states = base_state(Electron(), Incoming(), mom, AllSpin())\n2-element StaticArraysCore.SVector{2, BiSpinor} with indices SOneTo(2):\n [1.4379526505428235 + 0.0im, 0.0 + 0.0im, -0.20862995724285552 + 0.0im, -0.06954331908095185 - 0.1390866381619037im]\n [0.0 + 0.0im, 1.4379526505428235 + 0.0im, -0.06954331908095185 + 0.1390866381619037im, 0.20862995724285552 + 0.0im]\n\nnote: Iterator convenience\nThe returned objects of base_state can be consistently wrapped in an SVector for iteration using _as_svec.This way, a loop like the following becomes possible when spin may be definite or indefinite.for state in QEDbase._as_svec(base_state(Electron(), Incoming(), momentum, spin))\n    # ...\nend\n\nnote: Conventions\nFor an incoming fermion with momentum p, we use the explicit formula:u_sigma(p) = fracgamma^mu p_mu + msqrtvert p_0vert  + m eta_sigmawhere the elementary base spinors are given aseta_1 = (1 0 0 0)^T\neta_2 = (0 1 0 0)^TFor an outgoing anti-fermion with momentum p, we use the explicit formula:v_sigma(p) = frac-gamma^mu p_mu + msqrtvert p_0vert  + m chi_sigmawhere the elementary base spinors are given aschi_1 = (0 0 1 0)^T\nchi_2 = (0 0 0 1)^TFor outgoing fermions and incoming anti-fermions with momentum p, the base state is given as the Dirac-adjoint of the respective incoming fermion or outgoing anti-fermion state:overlineu_sigma(p) = u_sigma^dagger gamma^0\noverlinev_sigma(p) = v_sigma^dagger gamma^0where v_sigma is the base state of the respective outgoing anti-fermion.For a photon with four-momentum k^mu = omega (1 cosphi sintheta sinphi sintheta costheta), the two polarization vectors are given asbeginalign*\nepsilon^mu_1 = (0 costheta cosphi costheta sinphi -sintheta)\nepsilon^mu_2 = (0 -sinphi cosphi 0)\nendalign*\n\nwarning: Warning\nIn the current implementation there are no checks built-in, which verify the passed arguments whether they describe on-shell particles, i.e. p*p≈mass^2. Using base_state with off-shell particles will cause unpredictable behavior.\n\n\n\n\n\n","category":"function"},{"location":"library/particles/#QEDbase.propagator","page":"Particles","title":"QEDbase.propagator","text":"propagator(particle::AbstractParticleType, mom::QEDbase.AbstractFourMomentum)\n\nCompute the propagator of a particle for a given four-momentum mom.\n\nNotes on Convention\n\nThe QEDProcesses.jl package includes two types of propagators:\n\nBoson-like particles: For a BosonLike particle with four-momentum k and mass m = QEDbase.mass(particle), the propagator is given by:\n\nD(k) = frac1k^2 - m^2\n\nFermion-like particles: For a FermionLike particle with four-momentum p and mass m = QEDbase.mass(particle), the propagator is defined as:\n\nS(p) = fracgamma^mu p_mu + mp^2 - m^2\n\nHere, gamma^mu are the gamma matrices, and p_mu represents the four-momentum components.\n\nwarning: Warning\nThis function does not throw an error if the particle is off-shell (i.e., if it does not satisfy the mass-shell condition). In such cases, the function will return Inf, which indicates that the propagator is undefined for an off-shell particle.\n\n\n\n\n\n","category":"function"},{"location":"library/particles/#Optional-Interface","page":"Particles","title":"Optional Interface","text":"","category":"section"},{"location":"library/particles/","page":"Particles","title":"Particles","text":"is_fermion\nis_boson\nis_particle\nis_anti_particle","category":"page"},{"location":"library/particles/#QEDbase.is_fermion","page":"Particles","title":"QEDbase.is_fermion","text":"is_fermion(_::AbstractParticle) -> Bool\n\n\nInterface function for particles. Return true if the passed subtype of AbstractParticle can be considered a fermion in the sense of particle statistics, and false otherwise. The default implementation of is_fermion for every subtype of AbstractParticle will always return false.\n\n\n\n\n\n","category":"function"},{"location":"library/particles/#QEDbase.is_boson","page":"Particles","title":"QEDbase.is_boson","text":"is_boson(_::AbstractParticle) -> Bool\n\n\nInterface function for particles. Return true if the passed subtype of AbstractParticle can be considered a boson in the sense of particle statistics, and false otherwise. The default implementation of is_boson for every subtype of AbstractParticle will always return false.\n\n\n\n\n\n","category":"function"},{"location":"library/particles/#QEDbase.is_particle","page":"Particles","title":"QEDbase.is_particle","text":"is_particle(_::AbstractParticle) -> Bool\n\n\nInterface function for particles. Return true if the passed subtype of AbstractParticle can be considered a particle as distinct from anti-particles, and false otherwise. The default implementation of is_particle for every subtype of AbstractParticle will always return true.\n\n\n\n\n\n","category":"function"},{"location":"library/particles/#QEDbase.is_anti_particle","page":"Particles","title":"QEDbase.is_anti_particle","text":"is_anti_particle(_::AbstractParticle) -> Bool\n\n\nInterface function for particles. Return true if the passed subtype of AbstractParticle can be considered an anti particle as distinct from their particle counterpart, and false otherwise. The default implementation of is_anti_particle for every subtype of AbstractParticle will always return false.\n\n\n\n\n\n","category":"function"},{"location":"library/dirac_objects/#Dirac-Tensors","page":"Dirac tensors","title":"Dirac Tensors","text":"","category":"section"},{"location":"library/dirac_objects/","page":"Dirac tensors","title":"Dirac tensors","text":"AbstractDiracVector\nAbstractDiracMatrix","category":"page"},{"location":"library/dirac_objects/#QEDbase.AbstractDiracVector","page":"Dirac tensors","title":"QEDbase.AbstractDiracVector","text":"abstract type AbstractDiracVector{T} <: StaticArraysCore.FieldVector{4, T}\n\nAbstract type for Dirac vectors, e.g. four dimensional vectors from a spinor space.\n\n\n\n\n\n","category":"type"},{"location":"library/dirac_objects/#QEDbase.AbstractDiracMatrix","page":"Dirac tensors","title":"QEDbase.AbstractDiracMatrix","text":"abstract type AbstractDiracMatrix{T} <: StaticArraysCore.FieldMatrix{4, 4, T}\n\nAbstract type for Dirac matrices, i.e. matrix representations for linear mappings from a spinor space into another.\n\n\n\n\n\n","category":"type"},{"location":"library/utility/","page":"Utility","title":"Utility","text":"CurrentModule = QEDbase","category":"page"},{"location":"library/utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"library/utility/#Errors","page":"Utility","title":"Errors","text":"","category":"section"},{"location":"library/utility/","page":"Utility","title":"Utility","text":"\nInvalidInputError\nRegistryError","category":"page"},{"location":"library/utility/#QEDbase.InvalidInputError","page":"Utility","title":"QEDbase.InvalidInputError","text":"InvalidInputError(msg::String)\n\nException which is thrown if a function input is invalid.\n\n\n\n\n\n","category":"type"},{"location":"library/utility/#QEDbase.RegistryError","page":"Utility","title":"QEDbase.RegistryError","text":"struct RegistryError <: Exception\n\nException raised, if a certain type target_type can not be registed for a certain interface, since there needs the function func to be impleemnted.\n\nFields\n\nfunc::Function\ntarget_type::Any\n\n\n\n\n\n","category":"type"},{"location":"library/utility/#Helper-functions","page":"Utility","title":"Helper functions","text":"","category":"section"},{"location":"library/utility/","page":"Utility","title":"Utility","text":"_as_svec","category":"page"},{"location":"library/utility/#QEDbase._as_svec","page":"Utility","title":"QEDbase._as_svec","text":"_as_svec(x)\n\nAccepts a single object, an SVector of objects or a tuple of objects, and returns them in a single \"layer\" of SVector.\n\nUseful with base_state.\n\n\n\n\n\n","category":"function"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"EditURL = \"../tutorial/process.jl\"","category":"page"},{"location":"generated/process/#Tutorial:-Defining-a-Custom-Scattering-Process","page":"Scattering Process","title":"Tutorial: Defining a Custom Scattering Process","text":"","category":"section"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"In this tutorial, we'll define a custom scattering process by following the interface for AbstractProcessDefinition. We'll cover the necessary functions, including particle types, spin and polarization handling, and matrix element calculations.","category":"page"},{"location":"generated/process/#Step-1:-Define-a-Custom-Process-Type","page":"Scattering Process","title":"Step 1: Define a Custom Process Type","text":"","category":"section"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"Start by creating a custom type that inherits from AbstractProcessDefinition. This type will represent your process, for example, muon-anti-muon scattering into two photons.","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"using QEDbase\n\nredirect_stdout(devnull) do # hide\ninclude(joinpath(dirname(Base.active_project()), \"src\", \"tutorial\", \"particle.jl\"))          # to get predefined particles\ninclude(joinpath(dirname(Base.active_project()), \"src\", \"tutorial\", \"model.jl\"))             # to get the custom model\ninclude(joinpath(dirname(Base.active_project()), \"src\", \"tutorial\", \"four_momentum.jl\"))     # to get the custom four momenta\ninclude(joinpath(dirname(Base.active_project()), \"src\", \"tutorial\", \"phase_space_point.jl\")) # to get the custom phase space points\nend # hide","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"Define a specific process by creating a subtype of AbstractProcessDefinition:","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"struct MyProcess <: AbstractProcessDefinition\n    # Add relevant information, such as particle or any other process-specific properties.\n    incoming_particles::Tuple\n    outgoing_particles::Tuple\nend","category":"page"},{"location":"generated/process/#Step-2:-Implement-Required-Particle-Accessor-Functions","page":"Scattering Process","title":"Step 2: Implement Required Particle Accessor Functions","text":"","category":"section"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"Every process must define the incoming_particles and outgoing_particles functions to list the particles involved. These functions return tuples of particles.","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"QEDbase.incoming_particles(proc::MyProcess) = proc.incoming_particles\nQEDbase.outgoing_particles(proc::MyProcess) = proc.outgoing_particles","category":"page"},{"location":"generated/process/#Step-3:-Handle-Spins-and-Polarizations","page":"Scattering Process","title":"Step 3: Handle Spins and Polarizations","text":"","category":"section"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"To define the spin and polarization for the particles, overload incoming_spin_pols and outgoing_spin_pols. For our custom process, we assume average/summation over all spins and polarizations. However, you can define specific spins or polarizations if needed.","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"QEDbase.incoming_spin_pols(::MyProcess) = (AllSpin(), AllSpin())  # Both incoming particles are fermions (muon and antimuon)\nQEDbase.outgoing_spin_pols(::MyProcess) = (AllPolarization(), AllPolarization())  # Photons are boson","category":"page"},{"location":"generated/process/#Step-4:-Define-the-Matrix-Element-Calculation","page":"Scattering Process","title":"Step 4: Define the Matrix Element Calculation","text":"","category":"section"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"The matrix element is a central part of any scattering process. It needs to be implemented for each spin and polarization combination. To calculate matrix elements, you must define the _matrix_element function.","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"function QEDbase._matrix_element(psp::AbstractPhaseSpacePoint{MyProcess})\n    # Calculate the matrix element for the specific process.\n    # This is a placeholder for the actual computation.\n    return 1.0  # Placeholder value\nend","category":"page"},{"location":"generated/process/#Step-5:-Define-Incident-Flux","page":"Scattering Process","title":"Step 5: Define Incident Flux","text":"","category":"section"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"To compute the cross section, we need to define the incident flux. This function calculates the initial flux of incoming particles, based on their momenta and energies.","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"function QEDbase._incident_flux(psp::AbstractInPhaseSpacePoint{MyProcess})\n    # Placeholder calculation for incident flux\n    return 1.0  # Placeholder value\nend","category":"page"},{"location":"generated/process/#Step-6:-Averaging-Over-Spin-and-Polarization","page":"Scattering Process","title":"Step 6: Averaging Over Spin and Polarization","text":"","category":"section"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"Define the _averaging_norm function to return the normalization factor used to average the squared matrix elements over spins and polarizations.","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"function QEDbase._averaging_norm(proc::MyProcess)\n    # For example, if both incoming particles are fermions, the normalization could be the product of their spin multiplicity, i.e. 2 times 2.\n    return 4  # Placeholder value\nend","category":"page"},{"location":"generated/process/#Step-7:-Check-for-Physical-Phase-Space","page":"Scattering Process","title":"Step 7: Check for Physical Phase Space","text":"","category":"section"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"The _is_in_phasespace function verifies whether a particular combination of incoming and outgoing momenta is physically allowed (on-shell, momentum conservation, etc.).","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"function QEDbase._is_in_phasespace(psp::AbstractPhaseSpacePoint{MyProcess})\n    # Implement energy-momentum conservation and on-shell conditions.\n    return true  # Placeholder value\nend","category":"page"},{"location":"generated/process/#Step-8:-Define-the-Phase-Space-Factor","page":"Scattering Process","title":"Step 8: Define the Phase Space Factor","text":"","category":"section"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"To calculate cross sections, define the _phase_space_factor function, which returns the pre-differential factor of the invariant phase space integral measure.","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"function QEDbase._phase_space_factor(psp::AbstractPhaseSpacePoint{MyProcess})\n    # Return the phase space factor\n    return 1.0  # Placeholder value\nend","category":"page"},{"location":"generated/process/#Step-9:-Optional-Total-Probability-Calculation","page":"Scattering Process","title":"Step 9: Optional - Total Probability Calculation","text":"","category":"section"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"Optionally, you can define the _total_probability function to compute the total probability of the process. This is especially useful when computing total cross sections.","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"function QEDbase._total_probability(psp::AbstractPhaseSpacePoint{MyProcess})\n    # Calculate the total probability for the process\n    return 1.0  # Placeholder value\nend","category":"page"},{"location":"generated/process/#Putting-It-All-Together","page":"Scattering Process","title":"Putting It All Together","text":"","category":"section"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"After defining the required functions, you now have a complete process definition for MyProcess. This process can be used in phase space integration, cross section calculation, and other scattering computations in QuantumElectrodynamics.jl.","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"For example, if your process is muon-anti-muon scattering into two photons:","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"particles_in = (Muon(), AntiMuon())\nparticles_out = (Photon(), Photon())\nprocess = MyProcess(particles_in, particles_out)","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"You can then access the particles as follows:","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"println(\"incoming particles: \", incoming_particles(process))\nprintln(\"outgoing particles: \", outgoing_particles(process))","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"You can define some momenta for the incoming and outgoing particles","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"muon_mass = mass(Muon())\nmuon_momentum = CustomFourMomentum(500.0, 0, 0, sqrt(500.0^2 - muon_mass^2))\nantimuon_momentum = CustomFourMomentum(500.0, 0, 0, -sqrt(500.0^2 - muon_mass^2))\nincoming_momenta = (muon_momentum, antimuon_momentum)\nphoton_momentum1 = CustomFourMomentum(500.0, 500.0, 0, 0)\nphoton_momentum2 = CustomFourMomentum(500.0, -500.0, 0, 0)\noutgoing_momenta = (photon_momentum1, photon_momentum2)","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"And you can define phase space layouts and computational models (here just as placeholder):","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"psl = ExamplePhaseSpaceLayout()\nmodel = CustomModel()","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"Finally, you can build a phase space point for your process","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"incoming_ps =\n    ExampleParticleStateful.(Incoming(), incoming_particles(process), incoming_momenta)\noutgoing_ps =\n    ExampleParticleStateful.(Outgoing(), outgoing_particles(process), outgoing_momenta)\n\npsp = ExamplePhaseSpacePoint(process, model, psl, incoming_ps, outgoing_ps)","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"For this phase space point, the differential cross section can be calculated by calling","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"println(\"differential cross section: \", differential_cross_section(psp))","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"","category":"page"},{"location":"generated/process/","page":"Scattering Process","title":"Scattering Process","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/outline/#API-Outline","page":"Contents","title":"API Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"lorentz_vector.md\", \"function_index.md\"]","category":"page"},{"location":"phase_space_point/#What-is-a-Phase-Space-Point?","page":"Phase Space Points","title":"What is a Phase Space Point?","text":"","category":"section"},{"location":"phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"In high-energy physics, a phase space point represents a specific configuration of particles involved in a particle interaction or scattering process. More specifically, it refers to the set of momenta (and possibly other quantum states) of all the incoming and outgoing particles at a particular instant in the process.","category":"page"},{"location":"phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"For example, in a scattering process such as electron-positron annihilation:","category":"page"},{"location":"phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"e^+ + e^- to gamma + gamma","category":"page"},{"location":"phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"a phase space point would include the momenta (four-momenta, to be precise) of both the incoming particles (the positron (e^+) and electron (e^-)) and the outgoing particles (the two photons (\\gamma)). Each phase space point can be thought of as a snapshot of the physical state of the process at a given point in time.","category":"page"},{"location":"phase_space_point/#Why-is-it-important?","page":"Phase Space Points","title":"Why is it important?","text":"","category":"section"},{"location":"phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"In particle physics, calculations often involve integrating over all possible configurations of momenta that satisfy certain conservation laws (like energy and momentum conservation). The space of all these configurations is called the phase space, and each valid configuration is a phase space point. These points play a central role in computing things like cross sections, decay rates, and scattering amplitudes.","category":"page"},{"location":"phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"For any given process, we need a way to:","category":"page"},{"location":"phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"Represent the particles and their momenta in the phase space.\nEnsure that the representation is consistent with the underlying physics (e.g., the correct number and type of particles, momentum conservation).\nAccess the momenta of individual particles or compute derived quantities.","category":"page"},{"location":"phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"In this tutorial, we show how to create and use an ExamplePhaseSpacePoint, following the interface specification given by AbstractPhaseSpacePoint.","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"EditURL = \"../tutorial/particle.jl\"","category":"page"},{"location":"generated/particle/#tutorial_particle","page":"Particles","title":"Tutorial: Implementing a New Particle Type","text":"","category":"section"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"In this tutorial, we will implement a new particle type following the interface specification of AbstractParticle as used in QuantumElectrodynamics.jl. The AbstractParticle system has two main components:","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"Static functions: These functions determine the type of particle (fermion, boson, particle, or anti-particle). They provide compile-time information about the particle type.\nProperty functions: These functions define the physical properties of the particle, such as mass and charge.","category":"page"},{"location":"generated/particle/#Define-a-New-Particle-Species","page":"Particles","title":"Define a New Particle Species","text":"","category":"section"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"To start, we define a new concrete particle type that is a subtype of AbstractParticleType. For this example, we'll implement a new particle called Muon.","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"using QEDbase","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"Define a new particle species as a subtype of AbstractParticleType","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"struct Muon <: AbstractParticleType end","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"Since Muon is a subtype of AbstractParticleType, it is a singleton (no stateful properties). Implementing static functions for particle classification","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"QEDbase.is_fermion(::Muon) = true         # Muon is a fermion\nQEDbase.is_boson(::Muon) = false          # Muon is not a boson\nQEDbase.is_particle(::Muon) = true        # Muon is a particle (not an anti-particle)\nQEDbase.is_anti_particle(::Muon) = false  # Muon is not an anti-particle","category":"page"},{"location":"generated/particle/#Define-Physical-Properties","page":"Particles","title":"Define Physical Properties","text":"","category":"section"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"Next, we need to define the required property functions for mass and charge. These functions return the mass and charge of the Muon.","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"Define the physical properties of the Muon","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"QEDbase.mass(::Muon) = 105.66  # Muon mass in MeV/c^2\nQEDbase.charge(::Muon) = -1.0  # Muon has a charge of -1 (same as electron)","category":"page"},{"location":"generated/particle/#Anti-Particle-Implementation-(Optional)","page":"Particles","title":"Anti-Particle Implementation (Optional)","text":"","category":"section"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"If we want to define the anti-particle of the muon (anti-muon), we can do that by defining another particle type and changing the static functions accordingly.","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"Define the anti-particle of the Muon","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"struct AntiMuon <: AbstractParticleType end","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"Implement static functions for the AntiMuon","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"QEDbase.is_fermion(::AntiMuon) = true        # AntiMuon is also a fermion\nQEDbase.is_boson(::AntiMuon) = false         # AntiMuon is not a boson\nQEDbase.is_particle(::AntiMuon) = false      # AntiMuon is not a regular particle (it's an anti-particle)\nQEDbase.is_anti_particle(::AntiMuon) = true  # AntiMuon is an anti-particle","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"Define the physical properties for the AntiMuon","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"QEDbase.mass(::AntiMuon) = 105.66  # AntiMuon has the same mass as Muon\nQEDbase.charge(::AntiMuon) = 1.0   # AntiMuon has the opposite charge of Muon","category":"page"},{"location":"generated/particle/#Example-Usage","page":"Particles","title":"Example Usage","text":"","category":"section"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"Now we have both the Muon and its anti-particle (AntiMuon) implemented with the required interface functions. This makes these particles usable in QuantumElectrodynamics.jl processes.","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"Create a muon and an anti-muon","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"mu = Muon()\nanti_mu = AntiMuon()","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"Access particle properties","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"println(\"Is Muon a fermion? \", is_fermion(mu))            # true\nprintln(\"Is AntiMuon an anti-particle? \", is_anti_particle(anti_mu))  # true\nprintln(\"Muon mass: \", mass(mu), \" MeV/c^2\")              # 105.66 MeV/c^2\nprintln(\"AntiMuon charge: \", charge(anti_mu))             # +1.0","category":"page"},{"location":"generated/particle/#Summary","page":"Particles","title":"Summary","text":"","category":"section"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"In this tutorial, we have demonstrated how to implement a new particle type in QuantumElectrodynamics.jl. By following the interface specification for AbstractParticle, we created:","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"A new particle (Muon) and defined its static functions (is_fermion, is_boson, etc.),\nThe required property functions (mass and charge),\nAn anti-particle (AntiMuon) with opposite charge and appropriate static functions.","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"This setup makes these particles compatible with the rest of the QuantumElectrodynamics.jl framework and ready for use in particle physics simulations.","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"","category":"page"},{"location":"generated/particle/","page":"Particles","title":"Particles","text":"This page was generated using Literate.jl.","category":"page"},{"location":"refs/#References","page":"References","title":"References","text":"","category":"section"},{"location":"refs/","page":"References","title":"References","text":"","category":"page"},{"location":"library/cross_section/#Probability-and-Cross-Section","page":"Probability and cross section","title":"Probability and Cross Section","text":"","category":"section"},{"location":"library/cross_section/#Interface","page":"Probability and cross section","title":"Interface","text":"","category":"section"},{"location":"library/cross_section/","page":"Probability and cross section","title":"Probability and cross section","text":"CurrentModule = QEDbase","category":"page"},{"location":"library/cross_section/","page":"Probability and cross section","title":"Probability and cross section","text":"_incident_flux","category":"page"},{"location":"library/cross_section/#QEDbase._incident_flux","page":"Probability and cross section","title":"QEDbase._incident_flux","text":"_incident_flux(in_psp::InPhaseSpacePoint{PROC,MODEL}) where {\n    PROC <: AbstractProcessDefinition,\n    MODEL <: AbstractModelDefinition,\n}\n\nInterface function which returns the incident flux of the given scattering process for a given InPhaseSpacePoint.\n\n\n\n\n\n","category":"function"},{"location":"library/cross_section/#Differential-and-total-probability","page":"Probability and cross section","title":"Differential and total probability","text":"","category":"section"},{"location":"library/cross_section/","page":"Probability and cross section","title":"Probability and cross section","text":"differential_probability\nunsafe_differential_probability\ntotal_probability","category":"page"},{"location":"library/cross_section/#QEDbase.differential_probability","page":"Probability and cross section","title":"QEDbase.differential_probability","text":"differential_probability(phase_space_point::AbstractPhaseSpacePoint)\n\nIf the given phase spaces are physical, return differential probability evaluated on a phase space point. Zero otherwise.\n\n\n\n\n\n","category":"function"},{"location":"library/cross_section/#QEDbase.unsafe_differential_probability","page":"Probability and cross section","title":"QEDbase.unsafe_differential_probability","text":"unsafe_differential_probability(phase_space_point::AbstractPhaseSpacePoint)\n\nReturn differential probability evaluated on a phase space point without checking if the given phase space(s) are physical.\n\n\n\n\n\n","category":"function"},{"location":"library/cross_section/#QEDbase.total_probability","page":"Probability and cross section","title":"QEDbase.total_probability","text":"total_probability(in_psp::AbstractInPhaseSpacePoint)\n\nReturn the total probability of a given AbstractInPhaseSpacePoint.\n\n\n\n\n\n","category":"function"},{"location":"library/cross_section/#Differential-and-total-cross-section","page":"Probability and cross section","title":"Differential and total cross section","text":"","category":"section"},{"location":"library/cross_section/","page":"Probability and cross section","title":"Probability and cross section","text":"differential_cross_section\nunsafe_differential_cross_section\ntotal_cross_section","category":"page"},{"location":"library/cross_section/#QEDbase.differential_cross_section","page":"Probability and cross section","title":"QEDbase.differential_cross_section","text":"differential_cross_section(phase_space_point::PhaseSpacePoint)\n\nIf the given phase spaces are physical, return differential cross section evaluated on a phase space point. Zero otherwise.\n\n\n\n\n\n","category":"function"},{"location":"library/cross_section/#QEDbase.unsafe_differential_cross_section","page":"Probability and cross section","title":"QEDbase.unsafe_differential_cross_section","text":"unsafe_differential_cross_section(phase_space_point::AbstractPhaseSpacePoint)\n\nReturn the differential cross section evaluated on a phase space point without checking if the given phase space is physical.\n\n\n\n\n\n","category":"function"},{"location":"library/cross_section/#QEDbase.total_cross_section","page":"Probability and cross section","title":"QEDbase.total_cross_section","text":"total_cross_section(in_psp::AbstractInPhaseSpacePoint)\n\nReturn the total cross section for a given AbstractInPhaseSpacePoint.\n\n\n\n\n\n","category":"function"},{"location":"library/process/#Scattering-Process-Interface","page":"Scattering process","title":"Scattering Process Interface","text":"","category":"section"},{"location":"library/process/#Process-Interface","page":"Scattering process","title":"Process Interface","text":"","category":"section"},{"location":"library/process/","page":"Scattering process","title":"Scattering process","text":"AbstractProcessDefinition\nincoming_particles\noutgoing_particles\nincoming_spin_pols\noutgoing_spin_pols","category":"page"},{"location":"library/process/#QEDbase.AbstractProcessDefinition","page":"Scattering process","title":"QEDbase.AbstractProcessDefinition","text":"Abstract base type for definitions of scattering processes. It is the root type for the process interface, which assumes that every subtype of AbstractProcessDefinition implements at least\n\nincoming_particles(proc_def::AbstractProcessDefinition)\noutgoing_particles(proc_def::AbstractProcessDefinition)\n\nwhich return a tuple of the incoming and outgoing particles, respectively.\n\nAn AbstractProcessDefinition is also expected to contain spin and polarization information of its particles. For this, the functions\n\nincoming_spin_pols(proc_def::AbstractProcessDefinition)\noutgoing_spin_pols(proc_def::AbstractProcessDefinition)\n\ncan be overloaded. They must return a tuple of [AbstractSpinOrPolarization], where the order must match the order of the process' particles. A default implementation is provided which assumes AllSpin for every is_fermion particle and AllPolarization for every is_boson particle.\n\nnote: Performance\nIt is very beneficial for the performance of derived functions if these functions return compile-time-known values.\n\nOn top of these spin and polarization functions, the following functions are automatically defined:\n\nmultiplicity(proc_def::AbstractProcessDefinition)\nincoming_multiplicity(proc_def::AbstractProcessDefinition)\noutgoing_multiplicity(proc_def::AbstractProcessDefinition)\n\nWhich return the number of spin and polarization combinations that should be considered for the process. For more detail, refer to the functions' documentations.\n\nFurthermore, to calculate scattering probabilities and differential cross sections, the following interface functions need to be implemented for every combination of CustomProcess<:AbstractProcessDefinition, CustomModel<:AbstractModelDefinition, and CustomPhaseSpaceLayout<:AbstractPhaseSpaceLayout.\n\n    _incident_flux(psp::InPhaseSpacePoint{CustomProcess,CustomModel})\n\n    _matrix_element(psp::PhaseSpacePoint{CustomProcess,CustomModel})\n\n    _averaging_norm(proc::CustomProcess)\n\n    _is_in_phasespace(psp::PhaseSpacePoint{CustomProcess,CustomModel})\n\n    _phase_space_factor(psp::PhaseSpacePoint{CustomProcess,CustomModel,CustomPhaseSpaceLayout})\n\nOptional is the implementation of\n\n\n    _total_probability(psp::PhaseSpacePoint{CustomProcess,CustomModel,CustomPhaseSpaceLayout})\n\n\nto enable the calculation of total probabilities and cross sections.\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.incoming_particles","page":"Scattering process","title":"QEDbase.incoming_particles","text":"incoming_particles(proc_def::AbstractProcessDefinition)\n\nInterface function for scattering processes. Return a tuple of the incoming particles for the given process definition. This function needs to be given to implement the scattering process interface.\n\nnote: Performance\nIt is very beneficial for the performance of derived functions if this function returns compile-time-known values.\n\nSee also: AbstractParticleType\n\n\n\n\n\n","category":"function"},{"location":"library/process/#QEDbase.outgoing_particles","page":"Scattering process","title":"QEDbase.outgoing_particles","text":"outgoing_particles(proc_def::AbstractProcessDefinition)\n\nInterface function for scattering processes. Return the tuple of outgoing particles for the given process definition. This function needs to be given to implement the scattering process interface.\n\nnote: Performance\nIt is very beneficial for the performance of derived functions if this function returns compile-time-known values.\n\nSee also: AbstractParticleType\n\n\n\n\n\n","category":"function"},{"location":"library/process/#QEDbase.incoming_spin_pols","page":"Scattering process","title":"QEDbase.incoming_spin_pols","text":"incoming_spin_pols(proc_def::AbstractProcessDefinition)\n\nInterface function for scattering processes. Return the tuple of spins or polarizations for the given process definition. The order must be the same as the particles returned from incoming_particles. A default implementation is provided, returning AllSpin for every is_fermion and AllPolarization for every is_boson.\n\nnote: Performance\nIt is very beneficial for the performance of derived functions if this function returns compile-time-known values.\n\nSee also: AbstractSpinOrPolarization\n\n\n\n\n\n","category":"function"},{"location":"library/process/#QEDbase.outgoing_spin_pols","page":"Scattering process","title":"QEDbase.outgoing_spin_pols","text":"outgoing_spin_pols(proc_def::AbstractProcessDefinition)\n\nInterface function for scattering processes. Return the tuple of spins or polarizations for the given process definition. The order must be the same as the particles returned from outgoing_particles. A default implementation is provided, returning AllSpin for every is_fermion and AllPolarization for every is_boson.\n\nnote: Performance\nIt is very beneficial for the performance of derived functions if this function returns compile-time-known values.\n\nSee also: AbstractSpinOrPolarization\n\n\n\n\n\n","category":"function"},{"location":"library/process/#Particle-Directions","page":"Scattering process","title":"Particle Directions","text":"","category":"section"},{"location":"library/process/","page":"Scattering process","title":"Scattering process","text":"ParticleDirection\nIncoming\nOutgoing\nUnknownDirection\nis_incoming\nis_outgoing","category":"page"},{"location":"library/process/#QEDbase.ParticleDirection","page":"Scattering process","title":"QEDbase.ParticleDirection","text":"Abstract base type for the directions of particles in the context of processes, i.e. either they are incoming or outgoing. Subtypes of this are mostly used for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.Incoming","page":"Scattering process","title":"QEDbase.Incoming","text":"Incoming <: ParticleDirection\n\nConcrete implementation of a ParticleDirection to indicate that a particle is incoming in the context of a given process. Mostly used for dispatch.\n\njulia> using QEDbase\n\njulia> Incoming()\nincoming\n\nnote: ParticleDirection Interface\nBesides being a subtype of ParticleDirection, Incoming hasis_incoming(::Incoming) = true\nis_outgoing(::Incoming) = false\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.Outgoing","page":"Scattering process","title":"QEDbase.Outgoing","text":"Outgoing <: ParticleDirection\n\nConcrete implementation of a ParticleDirection to indicate that a particle is outgoing in the context of a given process. Mostly used for dispatch.\n\njulia> using QEDbase\n\njulia> Outgoing()\noutgoing\n\nnote: ParticleDirection Interface\nBesides being a subtype of ParticleDirection, Outgoing hasis_incoming(::Outgoing) = false\nis_outgoing(::Outgoing) = true\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.UnknownDirection","page":"Scattering process","title":"QEDbase.UnknownDirection","text":"UnknownDirection <: ParticleDirection\n\nConcrete implementation of a ParticleDirection to indicate that a particle has an unknown direction. This can mean that a specific direction does not make sense in the given context, that the direction is unavailable, or that it is unnecessary.\n\njulia> using QEDbase\n\njulia> UnknownDirection()\nunknown direction\n\nnote: ParticleDirection Interface\nBesides being a subtype of ParticleDirection, UnknownDirection hasis_incoming(::UnknownDirection) = false\nis_outgoing(::UnknownDirection) = false\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.is_incoming","page":"Scattering process","title":"QEDbase.is_incoming","text":"is_incoming(dir::ParticleDirection)\nis_incoming(particle::AbstractParticleStateful)\n\nConvenience function that returns true for Incoming and incoming AbstractParticleStateful and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"library/process/#QEDbase.is_outgoing","page":"Scattering process","title":"QEDbase.is_outgoing","text":"is_outgoing(dir::ParticleDirection)\nis_outgoing(particle::AbstractParticleStateful)\n\nConvenience function that returns true for Outgoing and outgoing AbstractParticleStateful and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"library/process/#Spins-and-Polarizations","page":"Scattering process","title":"Spins and Polarizations","text":"","category":"section"},{"location":"library/process/","page":"Scattering process","title":"Scattering process","text":"AbstractSpinOrPolarization\nspin_pols_iter","category":"page"},{"location":"library/process/#QEDbase.AbstractSpinOrPolarization","page":"Scattering process","title":"QEDbase.AbstractSpinOrPolarization","text":"Abstract base type for the spin or polarization of particles with is_fermion or is_boson, respectively.\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.spin_pols_iter","page":"Scattering process","title":"QEDbase.spin_pols_iter","text":"all_spin_pols(process::AbstractProcessDefinition)\n\nThis function returns an iterator, yielding every fully definite combination of spins and polarizations allowed by the process' spin_pols. Each returned element is a Tuple of the incoming and the outgoing spins and polarizations, in the order of the process' own spins and polarizations.\n\nThis works together with the definite spins and polarizations, AllSpin, AllPolarization, and the synced versions SyncedPolarization and SyncedSpin.\n\njulia> using QEDbase; using QEDcore; using QEDprocesses;\n\njulia> proc = ScatteringProcess((Photon(), Photon(), Photon(), Electron()), (Photon(), Electron()), (SyncedPolarization(1), SyncedPolarization(2), SyncedPolarization(1), SpinUp()), (SyncedPolarization(2), AllSpin()))\ngeneric QED process\n    incoming: photon (synced polarization 1), photon (synced polarization 2), photon (synced polarization 1), electron (spin up)\n    outgoing: photon (synced polarization 2), electron (all spins)\n\n\njulia> for sp_combo in spin_pols_iter(proc) println(sp_combo) end\n((x-polarized, x-polarized, x-polarized, spin up), (x-polarized, spin up))\n((y-polarized, x-polarized, y-polarized, spin up), (x-polarized, spin up))\n((x-polarized, y-polarized, x-polarized, spin up), (y-polarized, spin up))\n((y-polarized, y-polarized, y-polarized, spin up), (y-polarized, spin up))\n((x-polarized, x-polarized, x-polarized, spin up), (x-polarized, spin down))\n((y-polarized, x-polarized, y-polarized, spin up), (x-polarized, spin down))\n((x-polarized, y-polarized, x-polarized, spin up), (y-polarized, spin down))\n((y-polarized, y-polarized, y-polarized, spin up), (y-polarized, spin down))\n\njulia> length(spin_pols_iter(proc))\n8\n\n\n\n\n\n","category":"function"},{"location":"library/process/#Spins","page":"Scattering process","title":"Spins","text":"","category":"section"},{"location":"library/process/","page":"Scattering process","title":"Scattering process","text":"AbstractSpin\nAbstractDefiniteSpin\nAbstractIndefiniteSpin\nSpinUp\nSpinDown\nAllSpin\nSyncedSpin","category":"page"},{"location":"library/process/#QEDbase.AbstractSpin","page":"Scattering process","title":"QEDbase.AbstractSpin","text":"Abstract base type for the spin of particles with is_fermion.\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.AbstractDefiniteSpin","page":"Scattering process","title":"QEDbase.AbstractDefiniteSpin","text":"Abstract base type for definite spins of particles with is_fermion.\n\nConcrete types are SpinUp and SpinDown.\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.AbstractIndefiniteSpin","page":"Scattering process","title":"QEDbase.AbstractIndefiniteSpin","text":"Abstract base type for indefinite spins of particles with is_fermion.\n\nOne concrete type is AllSpin.\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.SpinUp","page":"Scattering process","title":"QEDbase.SpinUp","text":"Concrete type indicating that a particle with is_fermion has spin-up.\n\njulia> using QEDbase\n\njulia> SpinUp()\nspin up\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.SpinDown","page":"Scattering process","title":"QEDbase.SpinDown","text":"Concrete type indicating that a particle with is_fermion has spin-down.\n\njulia> using QEDbase\n\njulia> SpinDown()\nspin down\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.AllSpin","page":"Scattering process","title":"QEDbase.AllSpin","text":"Concrete type indicating that a particle with is_fermion has an indefinite spin and the differential cross section calculation should average or sum over all spins, depending on the direction (Incoming or Outgoing) of the particle in question.\n\njulia> using QEDbase\n\njulia> AllSpin()\nall spins\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.SyncedSpin","page":"Scattering process","title":"QEDbase.SyncedSpin","text":"SyncedSpin{N::Int} <: AbstractIndefiniteSpin\n\nAn indefinite spin type, indicating that multiple particles have a synced spin. Two spins are considered synced when they have the same value for N. This means that the resulting multiplicity will be 2 total for all particles with the same SyncedSpin.\n\nHaving a single SyncedSpin{N} in a process is legal. In this case, it behaves just like an AllSpin would.\n\nSee also: multiplicity\n\n\n\n\n\n","category":"type"},{"location":"library/process/#Polarization","page":"Scattering process","title":"Polarization","text":"","category":"section"},{"location":"library/process/","page":"Scattering process","title":"Scattering process","text":"AbstractPolarization\nAbstractDefinitePolarization\nAbstractIndefinitePolarization\nPolarizationX\nPolX\nPolarizationY\nPolY\nAllPolarization\nAllPol\nSyncedPolarization","category":"page"},{"location":"library/process/#QEDbase.AbstractPolarization","page":"Scattering process","title":"QEDbase.AbstractPolarization","text":"Abstract base type for the polarization of particles with is_boson.\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.AbstractDefinitePolarization","page":"Scattering process","title":"QEDbase.AbstractDefinitePolarization","text":"Abstract base type for definite polarization of particles with is_boson.\n\nConcrete types are PolarizationX and PolarizationY.\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.AbstractIndefinitePolarization","page":"Scattering process","title":"QEDbase.AbstractIndefinitePolarization","text":"Abstract base type for indefinite polarization of particles with is_boson.\n\nOne concrete type is AllPolarization.\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.PolarizationX","page":"Scattering process","title":"QEDbase.PolarizationX","text":"Concrete type which indicates, that a particle with is_boson has polarization in x-direction.\n\njulia> using QEDbase\n\njulia> PolX()\nx-polarized\n\nnote: Coordinate axes\nThe notion of axes, e.g. x- and y-direction is just to distinguish two orthogonal polarization directions. However, if the three-momentum of the particle with is_boson is aligned to the z-axis of a coordinate system, the polarization axes define the x- or y-axis, respectively.\n\ninfo: Alias\nThere is a built-in alias for PolarizationX:julia> using QEDbase\n\njulia> PolarizationX === PolX\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.PolX","page":"Scattering process","title":"QEDbase.PolX","text":"Concrete type which indicates, that a particle with is_boson has polarization in x-direction.\n\njulia> using QEDbase\n\njulia> PolX()\nx-polarized\n\nnote: Coordinate axes\nThe notion of axes, e.g. x- and y-direction is just to distinguish two orthogonal polarization directions. However, if the three-momentum of the particle with is_boson is aligned to the z-axis of a coordinate system, the polarization axes define the x- or y-axis, respectively.\n\ninfo: Alias\nThere is a built-in alias for PolarizationX:julia> using QEDbase\n\njulia> PolarizationX === PolX\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.PolarizationY","page":"Scattering process","title":"QEDbase.PolarizationY","text":"Concrete type which indicates, that a particle with is_boson has polarization in y-direction.\n\njulia> using QEDbase\n\njulia> PolY()\ny-polarized\n\nnote: Coordinate axes\nThe notion of axes, e.g. x- and y-direction is just to distinguish two orthogonal polarization directions. However, if the three-momentum of the particle with is_boson is aligned to the z-axis of a coordinate system, the polarization axes define the x- or y-axis, respectively.\n\ninfo: Alias\nThere is a built-in alias for PolarizationY:julia> using QEDbase\n\njulia> PolarizationY === PolY\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.PolY","page":"Scattering process","title":"QEDbase.PolY","text":"Concrete type which indicates, that a particle with is_boson has polarization in y-direction.\n\njulia> using QEDbase\n\njulia> PolY()\ny-polarized\n\nnote: Coordinate axes\nThe notion of axes, e.g. x- and y-direction is just to distinguish two orthogonal polarization directions. However, if the three-momentum of the particle with is_boson is aligned to the z-axis of a coordinate system, the polarization axes define the x- or y-axis, respectively.\n\ninfo: Alias\nThere is a built-in alias for PolarizationY:julia> using QEDbase\n\njulia> PolarizationY === PolY\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.AllPolarization","page":"Scattering process","title":"QEDbase.AllPolarization","text":"Concrete type indicating that a particle with is_boson has an indefinite polarization and the differential cross section calculation should average or sum over all polarizations, depending on the direction (Incoming or Outgoing) of the particle in question.\n\njulia> using QEDbase\n\njulia> AllPol()\nall polarizations\n\ninfo: Alias\nThere is a built-in alias for AllPolarization:julia> using QEDbase\n\njulia> AllPolarization === AllPol\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.AllPol","page":"Scattering process","title":"QEDbase.AllPol","text":"Concrete type indicating that a particle with is_boson has an indefinite polarization and the differential cross section calculation should average or sum over all polarizations, depending on the direction (Incoming or Outgoing) of the particle in question.\n\njulia> using QEDbase\n\njulia> AllPol()\nall polarizations\n\ninfo: Alias\nThere is a built-in alias for AllPolarization:julia> using QEDbase\n\njulia> AllPolarization === AllPol\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/process/#QEDbase.SyncedPolarization","page":"Scattering process","title":"QEDbase.SyncedPolarization","text":"SyncedPolarization{N::Int} <: AbstractIndefinitePolarization\n\nAn indefinite polarization type, indicating that multiple particles have a synced polarization. Two polarizations are considered synced when they have the same value for N. This means that the resulting multiplicity will be 2 total for all particles with the same SyncedPolarization.\n\nHaving a single SyncedPolarization{N} in a process is legal. In this case, it behaves just like an AllPolarization would.\n\nSee also: multiplicity\n\n\n\n\n\n","category":"type"},{"location":"library/process/#Utility-Functions","page":"Scattering process","title":"Utility Functions","text":"","category":"section"},{"location":"library/process/","page":"Scattering process","title":"Scattering process","text":"number_incoming_particles\nnumber_outgoing_particles\nparticles\nnumber_particles\nspin_pols\nmultiplicity\nincoming_multiplicity\noutgoing_multiplicity","category":"page"},{"location":"library/process/#QEDbase.number_incoming_particles","page":"Scattering process","title":"QEDbase.number_incoming_particles","text":"number_incoming_particles(proc_def::AbstractProcessDefinition)\n\nReturn the number of incoming particles of a given process.\n\n\n\n\n\n","category":"function"},{"location":"library/process/#QEDbase.number_outgoing_particles","page":"Scattering process","title":"QEDbase.number_outgoing_particles","text":"number_outgoing_particles(proc_def::AbstractProcessDefinition)\n\nReturn the number of outgoing particles of a given process.\n\n\n\n\n\n","category":"function"},{"location":"library/process/#QEDbase.particles","page":"Scattering process","title":"QEDbase.particles","text":"particles(proc_def::AbstractProcessDefinition, ::ParticleDirection)\n\nConvenience function dispatching to incoming_particles or outgoing_particles depending on the given direction.\n\n\n\n\n\n","category":"function"},{"location":"library/process/#QEDbase.number_particles","page":"Scattering process","title":"QEDbase.number_particles","text":"number_particles(proc_def::AbstractProcessDefinition, dir::ParticleDirection)\n\nConvenience function dispatching to number_incoming_particles or number_outgoing_particles depending on the given direction, returning the number of incoming or outgoing particles, respectively.\n\n\n\n\n\nnumber_particles(proc_def::AbstractProcessDefinition, dir::ParticleDirection, species::AbstractParticleType)\n\nReturn the number of particles of the given direction and species in the given process definition.\n\n\n\n\n\nnumber_particles(proc_def::AbstractProcessDefinition, particle::AbstractParticleStateful)\n\nReturn the number of particles of the given particle's direction and species in the given process definition.\n\n\n\n\n\n","category":"function"},{"location":"library/process/#QEDbase.spin_pols","page":"Scattering process","title":"QEDbase.spin_pols","text":"spin_pols(proc_def::AbstractProcessDefinition, dir::ParticleDirection)\n\nReturn the tuple of spins and polarizations for the process in the given direction. Dispatches to incoming_spin_pols or outgoing_spin_pols.\n\n\n\n\n\n","category":"function"},{"location":"library/process/#QEDbase.multiplicity","page":"Scattering process","title":"QEDbase.multiplicity","text":"multiplicity(proc::AbstractProcessDefinition)\n\nReturn the number of spin and polarization combinations represented by proc total. This depends on the specific AbstractSpinOrPolarizations returned by spin_pols for proc. For example, a default Compton process with four indefinite spins/polarizations has a multiplicity of 2^4 = 16. A Compton process with many incoming photons that have synced polarizations will still have a multiplicity of 16.\n\nnote: Performance\nAs long as incoming_spin_pols and outgoing_spin_pols can be evaluated at compile time, this function is completely compiled away.\n\nnote: Incoming and Outgoing Spins/Polarizations\nNote that the total multiplicity is not necessarily the incoming and outgoing multiplicities multiplied. This is the case when incoming and outgoing particles are synced with one another.\n\nSee also: SyncedPolarization, SyncedSpin, incoming_multiplicity, outgoing_multiplicity\n\n\n\n\n\n","category":"function"},{"location":"library/process/#QEDbase.incoming_multiplicity","page":"Scattering process","title":"QEDbase.incoming_multiplicity","text":"incoming_multiplicity(proc::AbstractProcessDefinition)\n\nReturn the number of spin and polarization combinations represented by procs incoming particles. This function only considers the incoming particles' spins and polarizations, returned by incoming_spin_pols for proc.\n\nnote: Incoming and Outgoing Spins/Polarizations\nNote that the total multiplicity is not necessarily the incoming and outgoing multiplicities multiplied. For the total process multiplicity, see multiplicity.\n\nSee also: SyncedPolarization, SyncedSpin, multiplicity, outgoing_multiplicity\n\n\n\n\n\n","category":"function"},{"location":"library/process/#QEDbase.outgoing_multiplicity","page":"Scattering process","title":"QEDbase.outgoing_multiplicity","text":"outgoing_multiplicity(proc::AbstractProcessDefinition)\n\nReturn the number of spin and polarization combinations represented by procs outgoing particles. This function only considers the outgoing particles' spins and polarizations, returned by outgoing_spin_pols for proc.\n\nnote: Incoming and Outgoing Spins/Polarizations\nNote that the total multiplicity is not necessarily the incoming and outgoing multiplicities multiplied. For the total process multiplicity, see multiplicity.\n\nSee also: SyncedPolarization, SyncedSpin, multiplicity, incoming_multiplicity\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#Mocking","page":"Testing functionality","title":"Mocking","text":"","category":"section"},{"location":"library/mocks/#Momenta","page":"Testing functionality","title":"Momenta","text":"","category":"section"},{"location":"library/mocks/","page":"Testing functionality","title":"Testing functionality","text":"QEDbase.Mocks.MockMomentum\nQEDbase.Mocks.MockMomentumMutable","category":"page"},{"location":"library/mocks/#QEDbase.Mocks.MockMomentum","page":"Testing functionality","title":"QEDbase.Mocks.MockMomentum","text":"struct MockMomentum{T} <: AbstractMockMomentum{T}\n\nA concrete implementation of a four-momentum with immutable components.\n\nFields\n\nE::T: Energy component.\npx::T: Momentum component in the x-direction.\npy::T: Momentum component in the y-direction.\npz::T: Momentum component in the z-direction.\n\nExample\n\np = MockMomentum(10.0, 1.0, 2.0, 3.0)\n\n\n\n\n\n","category":"type"},{"location":"library/mocks/#QEDbase.Mocks.MockMomentumMutable","page":"Testing functionality","title":"QEDbase.Mocks.MockMomentumMutable","text":"mutable struct MockMomentumMutable{T} <: AbstractMockMomentum{T}\n\nA concrete implementation of a four-momentum with mutable components.\n\nFields\n\nE::T: Energy component.\npx::T: Momentum component in the x-direction.\npy::T: Momentum component in the y-direction.\npz::T: Momentum component in the z-direction.\n\nUnlike MockMomentum, this struct allows modifying individual momentum components.\n\nExample\n\np = MockMomentumMutable(10.0, 1.0, 2.0, 3.0)\nQEDbase.setT!(p, 12.0)  # Modify energy\n\n\n\n\n\n","category":"type"},{"location":"library/mocks/#Model","page":"Testing functionality","title":"Model","text":"","category":"section"},{"location":"library/mocks/","page":"Testing functionality","title":"Testing functionality","text":"QEDbase.Mocks.MockModel\nQEDbase.Mocks.MockModel_FAIL\nQEDbase.Mocks._groundtruth_interaction_type","category":"page"},{"location":"library/mocks/#QEDbase.Mocks.MockModel","page":"Testing functionality","title":"QEDbase.Mocks.MockModel","text":"struct MockModel <: AbstractModelDefinition\n\nA mock model definition used for testing and validation purposes.\n\nThis model serves as a placeholder within the framework, returning a predefined interaction type when queried.\n\nMethods\n\nQEDbase.fundamental_interaction_type(::MockModel): Returns the fundamental interaction type by calling _groundtruth_interaction_type().\n\nExample\n\nmodel = MockModel()\ninteraction_type = QEDbase.fundamental_interaction_type(model)\n# Output: :mock_interaction\n\n\n\n\n\n","category":"type"},{"location":"library/mocks/#QEDbase.Mocks.MockModel_FAIL","page":"Testing functionality","title":"QEDbase.Mocks.MockModel_FAIL","text":"struct MockModel_FAIL <: AbstractModelDefinition\n\nA mock model definition intended to represent an incorrect or failing model.\n\nThis type can be used in tests to verify error handling and robustness of the framework when encountering invalid models.\n\nUsage\n\nMockModel_FAIL does not define fundamental_interaction_type and can be used to test behavior when a model lacks proper definitions.\n\nExample\n\nmodel_fail = MockModel_FAIL()\n# This may trigger an error if the framework expects a valid interaction type.\n\n\n\n\n\n","category":"type"},{"location":"library/mocks/#QEDbase.Mocks._groundtruth_interaction_type","page":"Testing functionality","title":"QEDbase.Mocks._groundtruth_interaction_type","text":"_groundtruth_interaction_type()::Symbol\n\nReturns the type of interaction associated with the mock setup.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#Coordinate-transformations","page":"Testing functionality","title":"Coordinate transformations","text":"","category":"section"},{"location":"library/mocks/","page":"Testing functionality","title":"Testing functionality","text":"QEDbase.Mocks.MockCoordinateTrafo\nQEDbase.Mocks._groundtruth_coord_trafo","category":"page"},{"location":"library/mocks/#QEDbase.Mocks.MockCoordinateTrafo","page":"Testing functionality","title":"QEDbase.Mocks.MockCoordinateTrafo","text":"MockCoordinateTrafo <: AbstractCoordinateTransformation\n\nA mock coordinate transformation that scales all momentum components by a factor of 2.\n\nThis transformation internally calls _groundtruth_coord_trafo.\n\nUsage\n\nThis type is used as a coordinate transformation within the context of QEDbase, applying _groundtruth_coord_trafo to momenta.\n\nExample\n\np = MockMomentum(rand(4))\ntrafo = MockCoordinateTrafo()\ntransformed_p = trafo(p)\n\n\n\n\n\n","category":"type"},{"location":"library/mocks/#QEDbase.Mocks._groundtruth_coord_trafo","page":"Testing functionality","title":"QEDbase.Mocks._groundtruth_coord_trafo","text":"_groundtruth_coord_trafo(p::AbstractMockMomentum)::AbstractMockMomentum\n_groundtruth_coord_trafo(psp::MockPhaseSpacePoint)::MockPhaseSpacePoint\n\nApplies a coordinate transformation to a given momentum p by multiplying it by 2. If a phase space point is given, the transformation is applied to all momenta.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#Cross-Section/Probability","page":"Testing functionality","title":"Cross Section/Probability","text":"","category":"section"},{"location":"library/mocks/","page":"Testing functionality","title":"Testing functionality","text":"QEDbase.Mocks._groundtruth_incident_flux\nQEDbase.Mocks._groundtruth_matrix_element\nQEDbase.Mocks._groundtruth_averaging_norm\nQEDbase.Mocks._groundtruth_is_in_phasespace\nQEDbase.Mocks._groundtruth_phase_space_factor\nQEDbase.Mocks._groundtruth_unsafe_probability\nQEDbase.Mocks._groundtruth_safe_probability\nQEDbase.Mocks._groundtruth_unsafe_diffCS\nQEDbase.Mocks._groundtruth_safe_diffCS\nQEDbase.Mocks._groundtruth_total_probability","category":"page"},{"location":"library/mocks/#QEDbase.Mocks._groundtruth_incident_flux","page":"Testing functionality","title":"QEDbase.Mocks._groundtruth_incident_flux","text":"_groundtruth_incident_flux(in_ps)\n\nMock implementation of the incident flux. Return the Minkowski square of the sum of the incoming momenta:\n\nbeginalign\nI = left(sum p_iright)^2\nendalign\n\nwhere p_iinmathrmps_in.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._groundtruth_matrix_element","page":"Testing functionality","title":"QEDbase.Mocks._groundtruth_matrix_element","text":"_groundtruth_matrix_element(in_ps, out_ps)\n\nMock implementation for a matrix elements. Returns a list of three complex numbers without any physical meaning.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._groundtruth_averaging_norm","page":"Testing functionality","title":"QEDbase.Mocks._groundtruth_averaging_norm","text":"_groundtruth_averaging_norm(proc)\n\nMock implementation of the averaging norm. Returns the inverse of the sum of all external particles of the passed process.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._groundtruth_is_in_phasespace","page":"Testing functionality","title":"QEDbase.Mocks._groundtruth_is_in_phasespace","text":"_groundtruth_is_in_phasespace(in_ps, out_ps)\n\nMock implementation of the phase space check. Return false if either the momentum of the first incoming particle is exactly zero(SFourMomentum), or if the momentum of the last outgoing momentum is exactly ones(SFourMomentum). Otherwise, return true.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._groundtruth_phase_space_factor","page":"Testing functionality","title":"QEDbase.Mocks._groundtruth_phase_space_factor","text":"_groundtruth_phase_space_factor(in_ps, out_ps)\n\nMock implementation of the phase space factor. Return the inverse of the product of the energies of all external particles.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._groundtruth_unsafe_probability","page":"Testing functionality","title":"QEDbase.Mocks._groundtruth_unsafe_probability","text":"_groundtruth_unsafe_probability(proc, in_ps, out_ps)\n\nMock implementation of the unsafe differential probability. Uses the test implementations of _groundtruth_matrix_element,_groundtruth_averaging_norm and _groundtruth_phase_space_factor.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._groundtruth_safe_probability","page":"Testing functionality","title":"QEDbase.Mocks._groundtruth_safe_probability","text":"_groundtruth_safe_probability(proc, in_ps, out_ps)\n\nMock implementation of the safe differential probability. Uses the test implementations of _groundtruth_is_in_phasespace and _groundtruth_unsafe_probability.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._groundtruth_unsafe_diffCS","page":"Testing functionality","title":"QEDbase.Mocks._groundtruth_unsafe_diffCS","text":"_groundtruth_unsafe_diffCS(proc, in_ps, out_ps)\n\nMock implementation of the unsafe differential cross section. Uses the test implementations of _groundtruth_incident_flux and _groundtruth_unsafe_probability.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._groundtruth_safe_diffCS","page":"Testing functionality","title":"QEDbase.Mocks._groundtruth_safe_diffCS","text":"_groundtruth_safe_diffCS(proc, in_ps, out_ps)\n\nMock implementation of the safe differential cross section. Uses the test implementations of _groundtruth_is_in_phasespace and _groundtruth_unsafe_diffCS.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._groundtruth_total_probability","page":"Testing functionality","title":"QEDbase.Mocks._groundtruth_total_probability","text":"_groundtruth_total_probability(in_ps::AbstractVector)\n\nMock implementation of the total cross section. Return the Minkowski square of the sum the momenta of all incoming particles.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#Phase-Space-Layout","page":"Testing functionality","title":"Phase Space Layout","text":"","category":"section"},{"location":"library/mocks/","page":"Testing functionality","title":"Testing functionality","text":"QEDbase.Mocks._groundtruth_in_moms\nQEDbase.Mocks._groundtruth_out_moms","category":"page"},{"location":"library/mocks/#QEDbase.Mocks._groundtruth_in_moms","page":"Testing functionality","title":"QEDbase.Mocks._groundtruth_in_moms","text":"_groundtruth_in_moms(in_coords,mom_type)\n\nMock implementation for building incoming momenta. Maps all components into four momenta.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._groundtruth_out_moms","page":"Testing functionality","title":"QEDbase.Mocks._groundtruth_out_moms","text":"_groundtruth_out_moms(Ptot,out_coords,mom_type)\n\nMock implementation for building outgoing momenta. Maps all components into four momenta and adds the last momentum via energy momentum conservation.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#Phase-Space-Point","page":"Testing functionality","title":"Phase Space Point","text":"","category":"section"},{"location":"library/mocks/","page":"Testing functionality","title":"Testing functionality","text":"QEDbase.Mocks.MockProcess\nQEDbase.Mocks.MockProcessSP\nQEDbase.Mocks.MockProcess_FAIL_ALL\nQEDbase.Mocks.MockProcess_FAIL_DIFFCS","category":"page"},{"location":"library/mocks/#QEDbase.Mocks.MockProcess","page":"Testing functionality","title":"QEDbase.Mocks.MockProcess","text":"MockProcess(rng,incoming_particles,outgoing_particles)\n\n\n\n\n\n","category":"type"},{"location":"library/mocks/#QEDbase.Mocks.MockProcessSP","page":"Testing functionality","title":"QEDbase.Mocks.MockProcessSP","text":"MockProcessSP\n\nProcess for testing with settable spin and polarization.\n\n\n\n\n\n","category":"type"},{"location":"library/mocks/#QEDbase.Mocks.MockProcess_FAIL_ALL","page":"Testing functionality","title":"QEDbase.Mocks.MockProcess_FAIL_ALL","text":"Mock process with no implemented interface. Should fail every usage except construction.\n\n\n\n\n\n","category":"type"},{"location":"library/mocks/#QEDbase.Mocks.MockProcess_FAIL_DIFFCS","page":"Testing functionality","title":"QEDbase.Mocks.MockProcess_FAIL_DIFFCS","text":"Mock process with no implemented interface except the incoming and outgoing particles. Should fail every usage except construction of itself and the respective phase space point for given four-momenta.\n\n\n\n\n\n","category":"type"},{"location":"library/mocks/#Random-Mock-Momenta","page":"Testing functionality","title":"Random Mock Momenta","text":"","category":"section"},{"location":"library/mocks/","page":"Testing functionality","title":"Testing functionality","text":"QEDbase.Mocks._rand_momenta\nQEDbase.Mocks._rand_in_momenta_failing\nQEDbase.Mocks._rand_out_momenta_failing\nQEDbase.Mocks._rand_in_momenta_failing_mix\nQEDbase.Mocks._rand_in_momenta_failing_all\nQEDbase.Mocks._rand_out_momenta_failing_mix\nQEDbase.Mocks._rand_out_momenta_failing_all","category":"page"},{"location":"library/mocks/#QEDbase.Mocks._rand_momenta","page":"Testing functionality","title":"QEDbase.Mocks._rand_momenta","text":"Return a tuple of random four momenta, i.e. a random phase space point.\n\n\n\n\n\nReturn a vector of tuples of random four momenta, i.e. a collection of phase space points. n1 is the size of the phase space point, n2 is the number of points.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._rand_in_momenta_failing","page":"Testing functionality","title":"QEDbase.Mocks._rand_in_momenta_failing","text":"Return a random phase space point that is failing the incoming phase space constraint, i.e. the first entry of the phase space is the null momentum.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._rand_out_momenta_failing","page":"Testing functionality","title":"QEDbase.Mocks._rand_out_momenta_failing","text":"Return a random phase space point that is failing the outgoing phase space constraint, i.e. the last entry of the phase space is the unit momentum.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._rand_in_momenta_failing_mix","page":"Testing functionality","title":"QEDbase.Mocks._rand_in_momenta_failing_mix","text":"Return a collection of incoming phase space points, where the first point is failing the phase space constraint, i.e. the first entry of the vector is invalid but the others pass. n1 is the size of the phase space point, n2 is the number of points.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._rand_in_momenta_failing_all","page":"Testing functionality","title":"QEDbase.Mocks._rand_in_momenta_failing_all","text":"Return a collection of incoming phase space points, where all points are failing the phase space constraint, i.e. their first entries are null momenta. n1 is the size of the phase space point, n2 is the number of points.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._rand_out_momenta_failing_mix","page":"Testing functionality","title":"QEDbase.Mocks._rand_out_momenta_failing_mix","text":"Return a vector of outgoing phase space points, where the first point is failing the phase space constraint, i.e. the last entry of the vector is invalid but the others pass. n1 is the size of the phase space point, n2 is the number of points.\n\n\n\n\n\n","category":"function"},{"location":"library/mocks/#QEDbase.Mocks._rand_out_momenta_failing_all","page":"Testing functionality","title":"QEDbase.Mocks._rand_out_momenta_failing_all","text":"Return a vector of outgoing phase space points, where all points are failing the phase space constraint, i.e. their last entries are unit momenta. n1 is the size of the phase space point, n2 is the number of points.\n\n\n\n\n\n","category":"function"},{"location":"library/function_index/#main-index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"EditURL = \"../tutorial/lorentz_vectors.jl\"","category":"page"},{"location":"generated/lorentz_vectors/#Tutorial:-Custom-Lorentz-Vectors","page":"Lorentz Vectors","title":"Tutorial: Custom Lorentz Vectors","text":"","category":"section"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"Lorentz vectors, which represent elements of Minkowski space, are fundamental mathematical objects in high-energy physics for describing the kinematic properties of particles. In particular, they are used to express four-momentum and other kinematic quantities.","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"QEDbase.jl provides a flexible interface for working with Lorentz vectors and four-momenta, allowing seamless integration with custom types that represent Lorentz vectors. This enables users to extend the core functionality of the package to their own data structures, while taking advantage of optimized kinematic computations.","category":"page"},{"location":"generated/lorentz_vectors/#Defining-a-Custom-Lorentz-Vector-Type","page":"Lorentz Vectors","title":"Defining a Custom Lorentz Vector Type","text":"","category":"section"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"The LorentzVector interface in QEDbase.jl is designed to be extendable. By implementing a simple API, you can make any custom type behave like a Lorentz vector and unlock access to various kinematic functions in the package.","category":"page"},{"location":"generated/lorentz_vectors/#Step-1:-Define-Your-Custom-Type","page":"Lorentz Vectors","title":"Step 1: Define Your Custom Type","text":"","category":"section"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"Suppose you want to define a custom type that behaves like a Lorentz vector. Start by creating the type to hold the Cartesian components of the vector:","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"using QEDbase\n\nstruct CustomLorentzVector\n    t::Float64   # time-like component\n    x::Float64   # x-component of spatial vector\n    y::Float64   # y-component of spatial vector\n    z::Float64   # z-component of spatial vector\nend","category":"page"},{"location":"generated/lorentz_vectors/#Step-2:-Implement-the-Lorentz-Vector-API","page":"Lorentz Vectors","title":"Step 2: Implement the Lorentz Vector API","text":"","category":"section"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"To connect your custom type to the LorentzVector interface, you'll need to implement the required getters for the time and spatial components. These functions extract the respective components (t, x, y, and z) from your type:","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"QEDbase.getT(lv::CustomLorentzVector) = lv.t\nQEDbase.getX(lv::CustomLorentzVector) = lv.x\nQEDbase.getY(lv::CustomLorentzVector) = lv.y\nQEDbase.getZ(lv::CustomLorentzVector) = lv.z","category":"page"},{"location":"generated/lorentz_vectors/#Step-3:-Register-Your-Custom-Type-as-a-LorentzVectorLike","page":"Lorentz Vectors","title":"Step 3: Register Your Custom Type as a LorentzVectorLike","text":"","category":"section"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"Once you've implemented the required API, you can register your custom type as a LorentzVectorLike by calling the following function:","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"register_LorentzVectorLike(CustomLorentzVector)","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"If any required functions are missing or incorrectly implemented, this will raise a RegistryError that provides details on what needs to be fixed.","category":"page"},{"location":"generated/lorentz_vectors/#Step-4:-Using-the-Custom-Lorentz-Vector","page":"Lorentz Vectors","title":"Step 4: Using the Custom Lorentz Vector","text":"","category":"section"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"With your custom type registered, you can now use it as a Lorentz vector in various kinematic calculations. For example, the CustomLorentzVector can be used to calculate angles or rapidity:","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"L = CustomLorentzVector(2.0, 1.0, 0.0, -1.0)\n\nprintln(\"Polar angle (theta)): \", getTheta(L))\nprintln(\"Rapidity: \", getRapidity(L))","category":"page"},{"location":"generated/lorentz_vectors/#Optional:-Mutable-Types","page":"Lorentz Vectors","title":"Optional: Mutable Types","text":"","category":"section"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"If you need to modify the components of the Lorentz vector after its creation, you can implement setter functions for your custom type. This will allow your type to be mutable and provide access to additional mutating functions within the QEDbase.jl ecosystem.","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"First: define another custom Lorentz vector type, but make it a mutable struct","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"mutable struct CustomMutableLorentzVector\n    t::Float64   # time-like component\n    x::Float64   # x-component of spatial vector\n    y::Float64   # y-component of spatial vector\n    z::Float64   # z-component of spatial vector\nend","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"Second: define the accessor functions for your mutable Lorentz vector","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"QEDbase.getT(lv::CustomMutableLorentzVector) = lv.t\nQEDbase.getX(lv::CustomMutableLorentzVector) = lv.x\nQEDbase.getY(lv::CustomMutableLorentzVector) = lv.y\nQEDbase.getZ(lv::CustomMutableLorentzVector) = lv.z","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"Third: enable mutability, implement the following setter methods","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"QEDbase.setT!(lv::CustomMutableLorentzVector, new_t) = (lv.t = new_t)\nQEDbase.setX!(lv::CustomMutableLorentzVector, new_x) = (lv.x = new_x)\nQEDbase.setY!(lv::CustomMutableLorentzVector, new_y) = (lv.y = new_y)\nQEDbase.setZ!(lv::CustomMutableLorentzVector, new_z) = (lv.z = new_z)","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"finally register your mutable Lorentz vector","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"register_LorentzVectorLike(CustomMutableLorentzVector)","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"Once these setter methods are defined, your type will support mutable operations. You can then register your type and take advantage of mutating functions provided by QEDbase.jl.","category":"page"},{"location":"generated/lorentz_vectors/#Example:-Updating-Rapidity","page":"Lorentz Vectors","title":"Example: Updating Rapidity","text":"","category":"section"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"After defining your custom type as mutable, you can use functions like setRapidity! to update the rapidity and other kinematic properties of the vector in place:","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"L = CustomMutableLorentzVector(2.0, 1.0, 0.0, -1.0)\n\nprintln(\"rapidity before: \", getRapidity(L))\nsetRapidity!(L, 0.5)  # Updates the components accordingly\nprintln(\"rapidity after: \", getRapidity(L))","category":"page"},{"location":"generated/lorentz_vectors/#Summary","page":"Lorentz Vectors","title":"Summary","text":"","category":"section"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"In this tutorial, we learned how to:","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"Define a custom type to represent a Lorentz vector.\nImplement the required API functions to integrate the type into the LorentzVector interface of QEDbase.jl.\nRegister the type as LorentzVectorLike to enable its use in kinematic calculations.\nOptionally, we explored how to make the custom type mutable and enable modification of its components.","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"By following these steps, you can extend QEDbase.jl to work with your own Lorentz vector types while benefiting from the library's optimized calculations.","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"","category":"page"},{"location":"generated/lorentz_vectors/","page":"Lorentz Vectors","title":"Lorentz Vectors","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"EditURL = \"../tutorial/phase_space_point.jl\"","category":"page"},{"location":"generated/phase_space_point/#tutorial_psp","page":"Phase Space Points","title":"Tutorial: Define a Custom Phase Space Point","text":"","category":"section"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"In this tutorial, we will define a custom phase space point type following the interface specification used in QuantumElectrodynamics.jl.","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"The AbstractPhaseSpacePoint system has three key components:","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"Scattering process: The definition of the process, which includes the incoming and outgoing particles.\nComputational model: The physics model, such as Quantum Electrodynamics (QED), that governs the dynamics of the particles.\nPhase space definition: The structure used to create phase space points from coordinates in the multidimensional phase space.","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"By the end of this tutorial, we’ll implement and test a custom phase space point using the electron-positron annihilation process:","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"e^+ + e^- rightarrow gamma + gamma","category":"page"},{"location":"generated/phase_space_point/#Step-0:-Import-the-Necessary-Ingredients","page":"Phase Space Points","title":"Step 0: Import the Necessary Ingredients","text":"","category":"section"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"We'll begin by importing necessary functionality from QEDbase, the muon and anti-muon particles from the particles tutorial, and the ParticleStateful from its respective tutorial.","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"using QEDbase\n\nredirect_stdout(devnull) do # hide\ninclude(joinpath(dirname(Base.active_project()), \"src\", \"tutorial\", \"particle.jl\"))          # to get predefined particles\ninclude(joinpath(dirname(Base.active_project()), \"src\", \"tutorial\", \"particle_stateful.jl\")) # to get custom particle stateful definition\nend # hide","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"We'll also need a Photon type which we briefly define right here.","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"struct Photon <: AbstractParticleType end\nQEDbase.is_boson(::Photon) = true\nQEDbase.is_particle(::Photon) = true\nQEDbase.is_anti_particle(::Photon) = true\nQEDbase.mass(::Photon) = 0.0\nQEDbase.charge(::Photon) = 0.0","category":"page"},{"location":"generated/phase_space_point/#Step-1:-Define-an-Example-Process","page":"Phase Space Points","title":"Step 1: Define an Example Process","text":"","category":"section"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"We define a process that describes muon-anti-muon annihilation. This process will involve two incoming particles (a muon and an anti-muon) and two outgoing particles (two photons).","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"struct ExampleProcess <: AbstractProcessDefinition end","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"Next, we specify the incoming and outgoing particles for the process by overloading the required interface functions:","category":"page"},{"location":"generated/phase_space_point/#Define-Incoming-and-Outgoing-Particles","page":"Phase Space Points","title":"Define Incoming and Outgoing Particles","text":"","category":"section"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"The incoming particles are a muon and an anti-muon, and the outgoing particles are two photons.","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"function QEDbase.incoming_particles(::ExampleProcess)\n    return (Muon(), AntiMuon())  # These particle types are defined in the particles tutorial.\nend\n\nfunction QEDbase.outgoing_particles(::ExampleProcess)\n    return (Photon(), Photon())  # Photons are defined above. They are also properly defined in QEDcore.\nend","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"At this point, we have defined our ExampleProcess with the required particles.","category":"page"},{"location":"generated/phase_space_point/#Step-2:-Implement-the-Model","page":"Phase Space Points","title":"Step 2: Implement the Model","text":"","category":"section"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"Next, we define a simple computational model, which will govern the behavior of the particles during the interaction.","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"struct ExampleModel <: AbstractModelDefinition end","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"This model can later be extended to incorporate complex QED interactions, but for now, we use it as a placeholder.","category":"page"},{"location":"generated/phase_space_point/#Step-3:-Define-Phase-Space-Layout","page":"Phase Space Points","title":"Step 3: Define Phase Space Layout","text":"","category":"section"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"The last part we need to implement is a phase space layout which describes the coordinate structure of the phase space:","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"struct ExamplePhaseSpaceLayout <: AbstractPhaseSpaceLayout end","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"This phase space layout can be extended later, but for now this is also a placeholder.","category":"page"},{"location":"generated/phase_space_point/#Step-4:-Define-an-Example-Phase-Space-Point","page":"Phase Space Points","title":"Step 4: Define an Example Phase Space Point","text":"","category":"section"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"We now define the ExamplePhaseSpacePoint type, which will represent a specific point in the phase space of the muon-anti-muon annihilation process. This type holds the process, the model, the phase space definition, and the incoming and outgoing particles.","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"struct ExamplePhaseSpacePoint{PROC,MODEL,PSL,IN_PARTICLES,OUT_PARTICLES} <:\n       AbstractPhaseSpacePoint{PROC,MODEL,PSL,IN_PARTICLES,OUT_PARTICLES}\n    proc::PROC\n    mdl::MODEL\n    psl::PSL\n    in_particles::IN_PARTICLES\n    out_particles::OUT_PARTICLES\nend","category":"page"},{"location":"generated/phase_space_point/#Step-5:-Implement-the-Interface-Functions","page":"Phase Space Points","title":"Step 5: Implement the Interface Functions","text":"","category":"section"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"Now, we implement the interface functions required by AbstractPhaseSpacePoint. These include functions for retrieving the process, model, phase space definition, and particle information.","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"function QEDbase.process(psp::ExamplePhaseSpacePoint)\n    return psp.proc\nend\n\nfunction QEDbase.model(psp::ExamplePhaseSpacePoint)\n    return psp.mdl\nend\n\nfunction QEDbase.phase_space_layout(psp::ExamplePhaseSpacePoint)\n    return psp.psl\nend\n\nfunction QEDbase.particles(psp::ExamplePhaseSpacePoint, dir::ParticleDirection)\n    if dir == Incoming()\n        return psp.in_particles\n    elseif dir == Outgoing()\n        return psp.out_particles\n    else\n        throw(ArgumentError(\"Invalid particle direction\"))\n    end\nend\n\nfunction Base.getindex(psp::ExamplePhaseSpacePoint, dir::ParticleDirection, n::Int)\n    return particles(psp, dir)[n]\nend","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"With these functions, we can now retrieve the process, model, phase space definition, and individual particles from our ExamplePhaseSpacePoint.","category":"page"},{"location":"generated/phase_space_point/#Step-6:-Access-momenta","page":"Phase Space Points","title":"Step 6: Access momenta","text":"","category":"section"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"The particles involved in the process have associated four-momenta, which describe their energy and momentum in spacetime. Let’s implement the functions to retrieve the momenta of particles.","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"Return the momentum of a specific particle","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"function QEDbase.momentum(psp::ExamplePhaseSpacePoint, dir::ParticleDirection, n::Int)\n    return momentum(particles(psp, dir)[n])\nend","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"Return a tuple of all momenta in a given direction","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"function QEDbase.momenta(psp::ExamplePhaseSpacePoint, dir::ParticleDirection)\n    return ntuple(i -> momentum(psp, dir, i), length(particles(psp, dir)))\nend","category":"page"},{"location":"generated/phase_space_point/#Step-7:-Test-the-Implementation","page":"Phase Space Points","title":"Step 7: Test the Implementation","text":"","category":"section"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"Finally, we’ll test our implementation using the muon-anti-muon annihilation process.","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"Create an instance of the process (ExampleProcess).\nCreate an instance of the model (ExampleModel).\nDefine the phase space layout (ExamplePhaseSpaceLayout).\nDefine the incoming and outgoing particles, specifying their four-momenta.\nCreate the phase space point and compute the momenta.","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"proc = ExampleProcess()\nmodel = ExampleModel()\npsl = ExamplePhaseSpaceLayout()\n\nin_particles = (\n    ExampleParticleStateful(Incoming(), Muon(), CustomFourMomentum(1.0, 0.0, 0.0, 1.0)),\n    ExampleParticleStateful(\n        Incoming(), AntiMuon(), CustomFourMomentum(1.0, 0.0, 0.0, -1.0)\n    ),\n)\n\nout_particles = (\n    ExampleParticleStateful(Outgoing(), Photon(), CustomFourMomentum(1.0, 1.0, 0.0, 0.0)),\n    ExampleParticleStateful(Outgoing(), Photon(), CustomFourMomentum(1.0, -1.0, 0.0, 0.0)),\n)\n\npsp = ExamplePhaseSpacePoint(proc, model, psl, in_particles, out_particles)\n\nincoming_momenta = momenta(psp, Incoming())\noutgoing_momenta = momenta(psp, Outgoing())\n\nprintln(\"Incoming momenta: \", incoming_momenta)\nprintln(\"Outgoing momenta: \", outgoing_momenta)","category":"page"},{"location":"generated/phase_space_point/#Conclusion","page":"Phase Space Points","title":"Conclusion","text":"","category":"section"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"We have successfully defined a custom phase space point type, implemented the necessary interface functions, and verified the momenta for a muon-anti-muon annihilation process. This phase space point system provides a flexible way to work with scattering processes.","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"","category":"page"},{"location":"generated/phase_space_point/","page":"Phase Space Points","title":"Phase Space Points","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/model/#Computational-Model-Interface","page":"Computational Model Interface","title":"Computational Model Interface","text":"","category":"section"},{"location":"library/model/","page":"Computational Model Interface","title":"Computational Model Interface","text":"AbstractModelDefinition\nfundamental_interaction_type","category":"page"},{"location":"library/model/#QEDbase.AbstractModelDefinition","page":"Computational Model Interface","title":"QEDbase.AbstractModelDefinition","text":"Abstract base type for all compute model definitions in the context of scattering processes. Every subtype of AbstractModelDefinition is associated with a fundamental interaction. Therefore, one needs to implement the following soft interface function\n\nfundamental_interaction_type(::AbstractModelDefinition)\n\n\n\n\n\n","category":"type"},{"location":"library/model/#QEDbase.fundamental_interaction_type","page":"Computational Model Interface","title":"QEDbase.fundamental_interaction_type","text":"fundamental_interaction_type(models_def::AbstractModelDefinition)\n\nReturn the fundamental interaction associated with the passed model definition.\n\n\n\n\n\n","category":"function"},{"location":"generated/four_momentum/","page":"Four Momentum","title":"Four Momentum","text":"EditURL = \"../tutorial/four_momentum.jl\"","category":"page"},{"location":"generated/four_momentum/#Tutorial:-Custom-Four-Momentum-Vector","page":"Four Momentum","title":"Tutorial: Custom Four Momentum Vector","text":"","category":"section"},{"location":"generated/four_momentum/","page":"Four Momentum","title":"Four Momentum","text":"This tutorial explains how to define a custom AbstractFourMomentum type that can be used to represent, for example, particle momenta in an AbstractParticleStateful.","category":"page"},{"location":"generated/four_momentum/#Defining-a-Custom-Four-Momentum-Type","page":"Four Momentum","title":"Defining a Custom Four Momentum Type","text":"","category":"section"},{"location":"generated/four_momentum/","page":"Four Momentum","title":"Four Momentum","text":"The FourMomentum interface in QEDbase.jl is designed to be extendable. By implementing a simple API, you can make any custom type behave like a Lorentz vector and unlock access to various kinematic functions in the package.","category":"page"},{"location":"generated/four_momentum/#Step-1:-Define-Your-Custom-Type","page":"Four Momentum","title":"Step 1: Define Your Custom Type","text":"","category":"section"},{"location":"generated/four_momentum/","page":"Four Momentum","title":"Four Momentum","text":"To define a valid AbstractFourMomentum type, create a type with the fields .E, .px, .py and .pz.","category":"page"},{"location":"generated/four_momentum/","page":"Four Momentum","title":"Four Momentum","text":"using QEDbase\n\nstruct CustomFourMomentum <: AbstractFourMomentum\n    E::Float64  # energy component\n    px::Float64 # x component\n    py::Float64 # y component\n    pz::Float64 # z component\nend","category":"page"},{"location":"generated/four_momentum/#Step-2:-Add-the-necessary-accessor-functions","page":"Four Momentum","title":"Step 2: Add the necessary accessor functions","text":"","category":"section"},{"location":"generated/four_momentum/","page":"Four Momentum","title":"Four Momentum","text":"QEDbase.getT(p::CustomFourMomentum) = p.E\nQEDbase.getX(p::CustomFourMomentum) = p.px\nQEDbase.getY(p::CustomFourMomentum) = p.py\nQEDbase.getZ(p::CustomFourMomentum) = p.pz","category":"page"},{"location":"generated/four_momentum/#Step-3:-Register-the-type-as-a-LorentzVectorLike","page":"Four Momentum","title":"Step 3: Register the type as a LorentzVectorLike","text":"","category":"section"},{"location":"generated/four_momentum/","page":"Four Momentum","title":"Four Momentum","text":"register_LorentzVectorLike(CustomFourMomentum)","category":"page"},{"location":"generated/four_momentum/","page":"Four Momentum","title":"Four Momentum","text":"A mutable version can also be implemented by also defining the interface functions setT!, setX!, setY!, and setZ!.","category":"page"},{"location":"generated/four_momentum/","page":"Four Momentum","title":"Four Momentum","text":"Example Usage:","category":"page"},{"location":"generated/four_momentum/","page":"Four Momentum","title":"Four Momentum","text":"mom = CustomFourMomentum(1.0, 0.0, 0.0, 1.0)\nprintln(\"Defined momentum $mom is on shell: $(isonshell(mom))\")","category":"page"},{"location":"generated/four_momentum/","page":"Four Momentum","title":"Four Momentum","text":"","category":"page"},{"location":"generated/four_momentum/","page":"Four Momentum","title":"Four Momentum","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/model/","page":"Physics Model","title":"Physics Model","text":"EditURL = \"../tutorial/model.jl\"","category":"page"},{"location":"generated/model/#Tutorial:-Custom-Physics-Model-Definition","page":"Physics Model","title":"Tutorial: Custom Physics Model Definition","text":"","category":"section"},{"location":"generated/model/","page":"Physics Model","title":"Physics Model","text":"In this tutorial, we define a custom physics model by implementing the AbstractModelDefinition interface from QEDbase.","category":"page"},{"location":"generated/model/","page":"Physics Model","title":"Physics Model","text":"First we need particle definitions from the particles tutorial:","category":"page"},{"location":"generated/model/","page":"Physics Model","title":"Physics Model","text":"redirect_stdout(devnull) do # hide\ninclude(joinpath(dirname(Base.active_project()), \"src\", \"tutorial\", \"particle.jl\"))    # to get predefined particles\nend # hide\n\nstruct CustomModel <: AbstractModelDefinition end","category":"page"},{"location":"generated/model/","page":"Physics Model","title":"Physics Model","text":"The fundamental interaction must be defined by a symbol:","category":"page"},{"location":"generated/model/","page":"Physics Model","title":"Physics Model","text":"QEDbase.fundamental_interaction_type(::CustomModel) = :electromagnetic","category":"page"},{"location":"generated/model/","page":"Physics Model","title":"Physics Model","text":"Next, we define the incoming and outgoing phase space dimensions:","category":"page"},{"location":"generated/model/","page":"Physics Model","title":"Physics Model","text":"function QEDbase.in_phase_space_dimension(proc::AbstractProcessDefinition, ::CustomModel)\n    return 3 * number_incoming_particles(proc) - 4 - 1\nend\n\nfunction QEDbase.out_phase_space_dimension(proc::AbstractProcessDefinition, ::CustomModel)\n    return 3 * number_outgoing_particles(proc) - 4\nend","category":"page"},{"location":"generated/model/","page":"Physics Model","title":"Physics Model","text":"The isphysical function should return whether the given process is physical in this model. For the electromagnetic interaction this means the fermion and anti-fermions need to match up.","category":"page"},{"location":"generated/model/","page":"Physics Model","title":"Physics Model","text":"function isphysical(proc::AbstractProcessDefinition, ::CustomModel)\n    return (\n        number_particles(proc, Incoming(), Muon()) +\n        number_particles(proc, Outgoing(), AntiMuon()) ==\n        number_particles(proc, Incoming(), AntiMuon()) +\n        number_particles(proc, Outgoing(), Muon())\n    ) && number_particles(proc, Incoming()) + number_particles(proc, Outgoing()) >= 2\nend","category":"page"},{"location":"generated/model/","page":"Physics Model","title":"Physics Model","text":"","category":"page"},{"location":"generated/model/","page":"Physics Model","title":"Physics Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"EditURL = \"../tutorial/particle_stateful.jl\"","category":"page"},{"location":"generated/particle_stateful/#Tutorial:-Implementing-a-Stateful-Particle","page":"Stateful Particles","title":"Tutorial: Implementing a Stateful Particle","text":"","category":"section"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"In this tutorial, we will extend particle types (like our Muon and AntiMuon from the previous tutorial) to implement stateful particles. A stateful particle is a particle that has runtime properties such as momentum, in addition to its compile-time species (like mass and charge).","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"This tutorial will guide you through the implementation of AbstractParticleStateful by creating stateful versions of particle types.","category":"page"},{"location":"generated/particle_stateful/#Define-a-Stateful-Particle-Type","page":"Stateful Particles","title":"Define a Stateful Particle Type","text":"","category":"section"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"To start, we need to define a concrete subtype of AbstractParticleStateful. A stateful particle must store information such as:","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"Direction: Incoming or outgoing (ParticleDirection).\nSpecies: The type of particle (AbstractParticleType).\nMomentum: The four-momentum of the particle (AbstractFourMomentum).","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"We will define a general ExampleParticleStateful type that can take any particle species as a type parameter. This type will also store the direction (incoming or outgoing) and the particle's four-momentum.","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"using QEDbase","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"Define a general stateful particle type that works for any particle species","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"struct ExampleParticleStateful{\n    DIR<:ParticleDirection,SPECIES<:AbstractParticleType,ELEMENT<:AbstractFourMomentum\n} <: AbstractParticleStateful{DIR,SPECIES,ELEMENT}\n    direction::DIR        # Incoming or outgoing\n    species::SPECIES      # Particle species (e.g., Muon, AntiMuon)\n    mom::ELEMENT          # Particle's four-momentum\nend","category":"page"},{"location":"generated/particle_stateful/#Implement-the-Interface-Functions","page":"Stateful Particles","title":"Implement the Interface Functions","text":"","category":"section"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"Next, we implement the required interface functions for ExampleParticleStateful, which are:","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"particle_direction\nparticle_species\nmomentum","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"These functions extract the respective properties from the ExampleParticleStateful object.","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"Define the particle_direction function","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"function QEDbase.particle_direction(part::ExampleParticleStateful)\n    return part.direction\nend","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"Define the particle_species function","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"function QEDbase.particle_species(part::ExampleParticleStateful)\n    return part.species\nend","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"Define the momentum function","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"function QEDbase.momentum(part::ExampleParticleStateful)\n    return part.mom\nend","category":"page"},{"location":"generated/particle_stateful/#Example-Usage","page":"Stateful Particles","title":"Example Usage","text":"","category":"section"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"We can now create instances of ExampleParticleStateful for, say, Muon and AntiMuon.","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"redirect_stdout(devnull) do # hide\n    include(joinpath(dirname(Base.active_project()), \"src\", \"tutorial\", \"particle.jl\"))          # to get predefined particles\n    include(joinpath(dirname(Base.active_project()), \"src\", \"tutorial\", \"four_momentum.jl\"))     # to get custom four momentum vector\nend # hide","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"Create a four-momentum vector (dummy example)","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"momentum_muon = CustomFourMomentum(1.0, 0.0, 0.0, 0.0);  # E, px, py, pz\nnothing #hide","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"Create an incoming Muon using ExampleParticleStateful","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"incoming_muon = ExampleParticleStateful(Incoming(), Muon(), momentum_muon);\nnothing #hide","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"Create an outgoing AntiMuon using ExampleParticleStateful","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"outgoing_antimuon = ExampleParticleStateful(Outgoing(), AntiMuon(), momentum_muon);\nnothing #hide","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"Access particle properties","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"println(\"Incoming muon mass: \", mass(particle_species(incoming_muon)))\nprintln(\n    \"Is the outgoing antimuon a fermion? \", is_fermion(particle_species(outgoing_antimuon))\n)","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"Access momentum","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"println(\"Incoming muon momentum: \", momentum(incoming_muon))\nprintln(\"Outgoing antimuon momentum: \", momentum(outgoing_antimuon))","category":"page"},{"location":"generated/particle_stateful/#Summary","page":"Stateful Particles","title":"Summary","text":"","category":"section"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"In this tutorial, we created a general ExampleParticleStateful type that can represent any particle species (like Muon or AntiMuon implemented in this tutorial, but also Electron and Positron from QEDcore) by using the species as a type parameter. This approach avoids the need to define separate stateful types for each particle, making the implementation more flexible and reusable.","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"The key steps were:","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"Defining the general ExampleParticleStateful type with parameters for direction, species, and momentum.\nImplementing the interface functions to retrieve direction, species, and momentum.\nUsing the generalized type for all subtypes of AbstractParticleType.","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"This method makes it easy to add more particles in the future while keeping the same structure.","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"note: Reference implementation\nA reference implementation of a stateful particle type is given by ParticleStateful","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"","category":"page"},{"location":"generated/particle_stateful/","page":"Stateful Particles","title":"Stateful Particles","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#QEDbase","page":"Home","title":"QEDbase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Doc Stable) (Image: Doc Dev) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"QEDbase.jl is a foundational package within the QuantumElectrodynamics.jl library. It provides essential interfaces and building blocks for the computation of quantum electrodynamics (QED) processes, facilitating interoperability with other packages in the suite.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a detailed explanation of the integration with other QuantumElectrodynamics.jl packages, please refer to the documentation of QuantumElectrodynamics.jl.","category":"page"},{"location":"#Main-interfaces","page":"Home","title":"Main interfaces","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Dirac Tensors: Types that facilitate operations involving Dirac matrices and spinors.\nLorentz Vectors: Types that facilitate operations involving Lorentz vectors.\nParticle Representation: Define particles with mass, charge, and other physical properties.\nComputation Models: Interfaces for implementing various physical models (e.g., perturbative or strong-field QED) for calculations.\nScattering Processes: Generic descriptions of scattering processes for use in QED calculations.\nProbabilities and Cross Sections: Core components for calculating differential probabilities and cross-sections.\nPhase Space Descriptions: Utility functions to define and manage phase spaces and related points.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To lern how to implement these interfaces, please refer to the tutorials in the documentation.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the latest stable version of QEDbase.jl, use the Julia package manager within the REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"QEDbase\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, you can enter the Pkg prompt by pressing ] in the Julia REPL and then run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add QEDbase","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are welcome! If you'd like to report a bug, suggest an enhancement, or contribute code, please feel free to open an issue or submit a pull request.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To ensure consistency across the QuantumElectrodynamics.jl ecosystem, we encourage all contributors to review the QuantumElectrodynamics.jl contribution guide.","category":"page"},{"location":"#Credits-and-contributors","page":"Home","title":"Credits and contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work was partly funded by the Center for Advanced Systems Understanding (CASUS) that is financed by Germany’s Federal Ministry of Education and Research (BMBF) and by the Saxon Ministry for Science, Culture and Tourism (SMWK) with tax funds on the basis of the budget approved by the Saxon State Parliament.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core code of the package QEDbase.jl is developed by a small team at the Center for Advanced Systems Understanding (CASUS), namely","category":"page"},{"location":"#Core-Contributors","page":"Home","title":"Core Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Uwe Hernandez Acosta (CASUS/HZDR, u.hernandez@hzdr.de)\nAnton Reinhard (CASUS/HZDR)\nSimeon Ehrig (CASUS/HZDR)\nKlaus Steiniger (CASUS/HZDR)","category":"page"},{"location":"#Former-Contributors","page":"Home","title":"Former Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tom Jungnickel","category":"page"},{"location":"","page":"Home","title":"Home","text":"We extend our sincere thanks to all contributors who have supported this project.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We extend our gratitude for the support received through direct and indirect funding for this project, especially","category":"page"},{"location":"","page":"Home","title":"Home","text":"Michael Bussmann\nTobias Dornheim","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIT © Uwe Hernandez Acosta","category":"page"},{"location":"library/phase_space/#Phase-Space-Description","page":"Phase space description","title":"Phase Space Description","text":"","category":"section"},{"location":"library/phase_space/#Stateful-Particles","page":"Phase space description","title":"Stateful Particles","text":"","category":"section"},{"location":"library/phase_space/","page":"Phase space description","title":"Phase space description","text":"AbstractParticleStateful\nmomentum","category":"page"},{"location":"library/phase_space/#QEDbase.AbstractParticleStateful","page":"Phase space description","title":"QEDbase.AbstractParticleStateful","text":"AbstractParticleStateful <: QEDbase.AbstractParticle\n\nAbstract base type for the representation of a particle with a state. It requires the following interface functions to be provided:\n\nparticle_direction: Returning the particle's direction.\nparticle_species: Returning the particle's species.\nmomentum: Returning the particle's momentum.\n\nImplementations for is_fermion, is_boson, is_particle, is_anti_particle, is_incoming, is_outgoing, mass, and charge are automatically provided using the interface functions above to fulfill the QEDbase.AbstractParticle interface.\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space/#QEDbase.momentum","page":"Phase space description","title":"QEDbase.momentum","text":"momentum(part::AbstractParticleStateful)\n\nInterface function that must return the particle's AbstractFourMomentum.\n\n\n\n\n\n","category":"function"},{"location":"library/phase_space/#Phasespace-Points","page":"Phase space description","title":"Phasespace Points","text":"","category":"section"},{"location":"library/phase_space/#Types","page":"Phase space description","title":"Types","text":"","category":"section"},{"location":"library/phase_space/","page":"Phase space description","title":"Phase space description","text":"AbstractPhaseSpacePoint\nAbstractInPhaseSpacePoint\nAbstractOutPhaseSpacePoint","category":"page"},{"location":"library/phase_space/#QEDbase.AbstractPhaseSpacePoint","page":"Phase space description","title":"QEDbase.AbstractPhaseSpacePoint","text":"AbstractPhaseSpacePoint{PROC, MODEL, PSL, IN_PARTICLES, OUT_PARTICLES}\n\nRepresentation of a point in the phase space of a process. It has several template arguments:\n\nPROC <:AbstractProcessDefinition\nMODEL <:AbstractModelDefinition\nPSL <:AbstractPhaseSpaceLayout\nIN_PARTICLES <:Tuple{Vararg{AbstractParticleStateful}}: The tuple type of all the incoming [AbstractParticleStateful`](@ref)s.\nOUT_PARTICLES <:Tuple{Vararg{AbstractParticleStateful}}: The tuple type of all the outgoing [AbstractParticleStateful`](@ref)s.\n\nThe following interface functions must be provided:\n\nBase.getindex(psp::AbstractPhaseSpacePoint, dir::ParticleDirection, n::Int): Return the nth AbstractParticleStateful of the given direction. Throw BoundsError for invalid indices.\nparticles(psp::AbstractPhaseSpacePoint, dir::ParticleDirection): Return the particle tuple (type IN_PARTICLES or OUT_PARTICLES depending on dir)\nprocess: Return the process.\nmodel: Return the model.\nphase_space_layout: Return the phase space layout.\n\nFrom this, the following functions are automatically derived:\n\nmomentum(psp::AbstractPhaseSpacePoint, dir::ParticleDirection, n::Int): Return the momentum of the nth AbstractParticleStateful of the given direction.\nmomenta(psp::PhaseSpacePoint, ::ParticleDirection): Return a Tuple of all the momenta of the given direction.\n\nFurthermore, an implementation of an AbstractPhaseSpacePoint has to verify on construction that it is valid, i.e., the following conditions are fulfilled:\n\nIN_PARTICLES must match incoming_particles(::PROC) in length, order, and type or be an empty Tuple.\nOUT_PARTICLES must match the outgoing_particles(::PROC) in length, order, and type, or be an empty Tuple.\nIN_PARTICLES and OUT_PARTICLES may not both be empty.\n\nIf IN_PARTICLES is non-empty, AbstractPhaseSpacePoint <: AbstractInPhaseSpacePoint is true. Likewise, if OUT_PARTICLES is non-empty, AbstractPhaseSpacePoint <: AbstractOutPhaseSpacePoint is true. Consequently, if both IN_PARTICLES and OUT_PARTICLES are non-empty, both <: statements are true.\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space/#QEDbase.AbstractInPhaseSpacePoint","page":"Phase space description","title":"QEDbase.AbstractInPhaseSpacePoint","text":"AbstractInPhaseSpacePoint\n\nA partial type specialization on AbstractPhaseSpacePoint which can be used for dispatch in functions requiring only the in channel of the phase space to exist, for example implementations of _incident_flux. No restrictions are imposed on the out-channel, which may or may not exist.\n\nSee also: AbstractOutPhaseSpacePoint\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space/#QEDbase.AbstractOutPhaseSpacePoint","page":"Phase space description","title":"QEDbase.AbstractOutPhaseSpacePoint","text":"AbstractOutPhaseSpacePoint\n\nA partial type specialization on AbstractPhaseSpacePoint which can be used for dispatch in functions requiring only the out channel of the phase space to exist. No restrictions are imposed on the in-channel, which may or may not exist.\n\nSee also: AbstractInPhaseSpacePoint\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space/#Interface","page":"Phase space description","title":"Interface","text":"","category":"section"},{"location":"library/phase_space/","page":"Phase space description","title":"Phase space description","text":"process\nmodel\nphase_space_layout","category":"page"},{"location":"library/phase_space/#QEDbase.process","page":"Phase space description","title":"QEDbase.process","text":"process(psp::AbstractPhaseSpacePoint)\n\nReturn the phase space point's set process.\n\nSee also: AbstractProcessDefinition\n\n\n\n\n\n","category":"function"},{"location":"library/phase_space/#QEDbase.model","page":"Phase space description","title":"QEDbase.model","text":"model(psp::AbstractPhaseSpacePoint)\n\nReturn the phase space point's set model.\n\nSee also: AbstractModelDefinition\n\n\n\n\n\n","category":"function"},{"location":"library/phase_space/#QEDbase.phase_space_layout","page":"Phase space description","title":"QEDbase.phase_space_layout","text":"phase_space_layout(psp::AbstractPhaseSpacePoint)\n\nReturn the phase space point's set phase space layout.\n\nSee also: AbstractPhaseSpaceLayout\n\n\n\n\n\n","category":"function"},{"location":"library/phase_space/#Convenience-Functions","page":"Phase space description","title":"Convenience Functions","text":"","category":"section"},{"location":"library/phase_space/","page":"Phase space description","title":"Phase space description","text":"particle_direction\nparticle_species\nmomenta","category":"page"},{"location":"library/phase_space/#QEDbase.particle_direction","page":"Phase space description","title":"QEDbase.particle_direction","text":"particle_direction(part::AbstractParticleStateful)\n\nInterface function that must return the particle's ParticleDirection.\n\n\n\n\n\n","category":"function"},{"location":"library/phase_space/#QEDbase.particle_species","page":"Phase space description","title":"QEDbase.particle_species","text":"particle_species(part::AbstractParticleStateful)\n\nInterface function that must return the particle's AbstractParticleType, e.g. QEDcore.Electron().\n\n\n\n\n\n","category":"function"},{"location":"library/phase_space/#QEDbase.momenta","page":"Phase space description","title":"QEDbase.momenta","text":"momenta(psp::AbstractPhaseSpacePoint, ::ParticleDirection)\n\nReturn a Tuple of all the particles' momenta for the given ParticleDirection.\n\n\n\n\n\n","category":"function"}]
}
